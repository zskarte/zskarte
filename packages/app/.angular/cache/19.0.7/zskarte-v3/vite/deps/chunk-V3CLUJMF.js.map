{
  "version": 3,
  "sources": ["../../../../../../../../node_modules/ol/expr/cpu.js", "../../../../../../../../node_modules/ol/render/canvas/style.js", "../../../../../../../../node_modules/ol/layer/BaseVector.js"],
  "sourcesContent": ["/**\n * @module ol/expr/cpu\n */\n\nimport { ColorType, LiteralExpression, Ops, parse } from './expression.js';\nimport { fromString, lchaToRgba, normalize, rgbaToLcha, toString, withAlpha } from '../color.js';\n\n/**\n * @fileoverview This module includes functions to build expressions for evaluation on the CPU.\n * Building is composed of two steps: parsing and compiling.  The parsing step takes an encoded\n * expression and returns an instance of one of the expression classes.  The compiling step takes\n * the expression instance and returns a function that can be evaluated in to return a literal\n * value.  The evaluator function should do as little allocation and work as possible.\n */\n\n/**\n * @typedef {Object} EvaluationContext\n * @property {Object} properties The values for properties used in 'get' expressions.\n * @property {Object} variables The values for variables used in 'var' expressions.\n * @property {number} resolution The map resolution.\n * @property {string|number|null} featureId The feature id.\n * @property {string} geometryType Geometry type of the current object.\n */\n\n/**\n * @return {EvaluationContext} A new evaluation context.\n */\nexport function newEvaluationContext() {\n  return {\n    variables: {},\n    properties: {},\n    resolution: NaN,\n    featureId: null,\n    geometryType: ''\n  };\n}\n\n/**\n * @typedef {function(EvaluationContext):import(\"./expression.js\").LiteralValue} ExpressionEvaluator\n */\n\n/**\n * @typedef {function(EvaluationContext):boolean} BooleanEvaluator\n */\n\n/**\n * @typedef {function(EvaluationContext):number} NumberEvaluator\n */\n\n/**\n * @typedef {function(EvaluationContext):string} StringEvaluator\n */\n\n/**\n * @typedef {function(EvaluationContext):(Array<number>|string)} ColorLikeEvaluator\n */\n\n/**\n * @typedef {function(EvaluationContext):Array<number>} NumberArrayEvaluator\n */\n\n/**\n * @typedef {function(EvaluationContext):Array<number>} CoordinateEvaluator\n */\n\n/**\n * @typedef {function(EvaluationContext):(Array<number>)} SizeEvaluator\n */\n\n/**\n * @typedef {function(EvaluationContext):(Array<number>|number)} SizeLikeEvaluator\n */\n\n/**\n * @param {import('./expression.js').EncodedExpression} encoded The encoded expression.\n * @param {number} type The expected type.\n * @param {import('./expression.js').ParsingContext} context The parsing context.\n * @return {ExpressionEvaluator} The expression evaluator.\n */\nexport function buildExpression(encoded, type, context) {\n  const expression = parse(encoded, type, context);\n  return compileExpression(expression, context);\n}\n\n/**\n * @param {import(\"./expression.js\").Expression} expression The expression.\n * @param {import('./expression.js').ParsingContext} context The parsing context.\n * @return {ExpressionEvaluator} The evaluator function.\n */\nfunction compileExpression(expression, context) {\n  if (expression instanceof LiteralExpression) {\n    // convert colors to array if possible\n    if (expression.type === ColorType && typeof expression.value === 'string') {\n      const colorValue = fromString(expression.value);\n      return function () {\n        return colorValue;\n      };\n    }\n    return function () {\n      return expression.value;\n    };\n  }\n  const operator = expression.operator;\n  switch (operator) {\n    case Ops.Number:\n    case Ops.String:\n    case Ops.Coalesce:\n      {\n        return compileAssertionExpression(expression, context);\n      }\n    case Ops.Get:\n    case Ops.Var:\n    case Ops.Has:\n      {\n        return compileAccessorExpression(expression, context);\n      }\n    case Ops.Id:\n      {\n        return context => context.featureId;\n      }\n    case Ops.GeometryType:\n      {\n        return context => context.geometryType;\n      }\n    case Ops.Concat:\n      {\n        const args = expression.args.map(e => compileExpression(e, context));\n        return context => ''.concat(...args.map(arg => arg(context).toString()));\n      }\n    case Ops.Resolution:\n      {\n        return context => context.resolution;\n      }\n    case Ops.Any:\n    case Ops.All:\n    case Ops.Between:\n    case Ops.In:\n    case Ops.Not:\n      {\n        return compileLogicalExpression(expression, context);\n      }\n    case Ops.Equal:\n    case Ops.NotEqual:\n    case Ops.LessThan:\n    case Ops.LessThanOrEqualTo:\n    case Ops.GreaterThan:\n    case Ops.GreaterThanOrEqualTo:\n      {\n        return compileComparisonExpression(expression, context);\n      }\n    case Ops.Multiply:\n    case Ops.Divide:\n    case Ops.Add:\n    case Ops.Subtract:\n    case Ops.Clamp:\n    case Ops.Mod:\n    case Ops.Pow:\n    case Ops.Abs:\n    case Ops.Floor:\n    case Ops.Ceil:\n    case Ops.Round:\n    case Ops.Sin:\n    case Ops.Cos:\n    case Ops.Atan:\n    case Ops.Sqrt:\n      {\n        return compileNumericExpression(expression, context);\n      }\n    case Ops.Case:\n      {\n        return compileCaseExpression(expression, context);\n      }\n    case Ops.Match:\n      {\n        return compileMatchExpression(expression, context);\n      }\n    case Ops.Interpolate:\n      {\n        return compileInterpolateExpression(expression, context);\n      }\n    case Ops.ToString:\n      {\n        return compileConvertExpression(expression, context);\n      }\n    default:\n      {\n        throw new Error(`Unsupported operator ${operator}`);\n      }\n    // TODO: unimplemented\n    // Ops.Zoom\n    // Ops.Time\n    // Ops.Array\n    // Ops.Color\n    // Ops.Band\n    // Ops.Palette\n  }\n}\n\n/**\n * @param {import('./expression.js').CallExpression} expression The call expression.\n * @param {import('./expression.js').ParsingContext} context The parsing context.\n * @return {ExpressionEvaluator} The evaluator function.\n */\nfunction compileAssertionExpression(expression, context) {\n  const type = expression.operator;\n  const length = expression.args.length;\n  const args = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    args[i] = compileExpression(expression.args[i], context);\n  }\n  switch (type) {\n    case Ops.Coalesce:\n      {\n        return context => {\n          for (let i = 0; i < length; ++i) {\n            const value = args[i](context);\n            if (typeof value !== 'undefined' && value !== null) {\n              return value;\n            }\n          }\n          throw new Error('Expected one of the values to be non-null');\n        };\n      }\n    case Ops.Number:\n    case Ops.String:\n      {\n        return context => {\n          for (let i = 0; i < length; ++i) {\n            const value = args[i](context);\n            if (typeof value === type) {\n              return value;\n            }\n          }\n          throw new Error(`Expected one of the values to be a ${type}`);\n        };\n      }\n    default:\n      {\n        throw new Error(`Unsupported assertion operator ${type}`);\n      }\n  }\n}\n\n/**\n * @param {import('./expression.js').CallExpression} expression The call expression.\n * @param {import('./expression.js').ParsingContext} context The parsing context.\n * @return {ExpressionEvaluator} The evaluator function.\n */\nfunction compileAccessorExpression(expression, context) {\n  const nameExpression = /** @type {LiteralExpression} */expression.args[0];\n  const name = /** @type {string} */nameExpression.value;\n  switch (expression.operator) {\n    case Ops.Get:\n      {\n        return context => {\n          const args = expression.args;\n          let value = context.properties[name];\n          for (let i = 1, ii = args.length; i < ii; ++i) {\n            const keyExpression = /** @type {LiteralExpression} */args[i];\n            const key = /** @type {string|number} */keyExpression.value;\n            value = value[key];\n          }\n          return value;\n        };\n      }\n    case Ops.Var:\n      {\n        return context => context.variables[name];\n      }\n    case Ops.Has:\n      {\n        return context => {\n          const args = expression.args;\n          if (!(name in context.properties)) {\n            return false;\n          }\n          let value = context.properties[name];\n          for (let i = 1, ii = args.length; i < ii; ++i) {\n            const keyExpression = /** @type {LiteralExpression} */args[i];\n            const key = /** @type {string|number} */keyExpression.value;\n            if (!value || !Object.hasOwn(value, key)) {\n              return false;\n            }\n            value = value[key];\n          }\n          return true;\n        };\n      }\n    default:\n      {\n        throw new Error(`Unsupported accessor operator ${expression.operator}`);\n      }\n  }\n}\n\n/**\n * @param {import('./expression.js').CallExpression} expression The call expression.\n * @param {import('./expression.js').ParsingContext} context The parsing context.\n * @return {BooleanEvaluator} The evaluator function.\n */\nfunction compileComparisonExpression(expression, context) {\n  const op = expression.operator;\n  const left = compileExpression(expression.args[0], context);\n  const right = compileExpression(expression.args[1], context);\n  switch (op) {\n    case Ops.Equal:\n      {\n        return context => left(context) === right(context);\n      }\n    case Ops.NotEqual:\n      {\n        return context => left(context) !== right(context);\n      }\n    case Ops.LessThan:\n      {\n        return context => left(context) < right(context);\n      }\n    case Ops.LessThanOrEqualTo:\n      {\n        return context => left(context) <= right(context);\n      }\n    case Ops.GreaterThan:\n      {\n        return context => left(context) > right(context);\n      }\n    case Ops.GreaterThanOrEqualTo:\n      {\n        return context => left(context) >= right(context);\n      }\n    default:\n      {\n        throw new Error(`Unsupported comparison operator ${op}`);\n      }\n  }\n}\n\n/**\n * @param {import('./expression.js').CallExpression} expression The call expression.\n * @param {import('./expression.js').ParsingContext} context The parsing context.\n * @return {BooleanEvaluator} The evaluator function.\n */\nfunction compileLogicalExpression(expression, context) {\n  const op = expression.operator;\n  const length = expression.args.length;\n  const args = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    args[i] = compileExpression(expression.args[i], context);\n  }\n  switch (op) {\n    case Ops.Any:\n      {\n        return context => {\n          for (let i = 0; i < length; ++i) {\n            if (args[i](context)) {\n              return true;\n            }\n          }\n          return false;\n        };\n      }\n    case Ops.All:\n      {\n        return context => {\n          for (let i = 0; i < length; ++i) {\n            if (!args[i](context)) {\n              return false;\n            }\n          }\n          return true;\n        };\n      }\n    case Ops.Between:\n      {\n        return context => {\n          const value = args[0](context);\n          const min = args[1](context);\n          const max = args[2](context);\n          return value >= min && value <= max;\n        };\n      }\n    case Ops.In:\n      {\n        return context => {\n          const value = args[0](context);\n          for (let i = 1; i < length; ++i) {\n            if (value === args[i](context)) {\n              return true;\n            }\n          }\n          return false;\n        };\n      }\n    case Ops.Not:\n      {\n        return context => !args[0](context);\n      }\n    default:\n      {\n        throw new Error(`Unsupported logical operator ${op}`);\n      }\n  }\n}\n\n/**\n * @param {import('./expression.js').CallExpression} expression The call expression.\n * @param {import('./expression.js').ParsingContext} context The parsing context.\n * @return {NumberEvaluator} The evaluator function.\n */\nfunction compileNumericExpression(expression, context) {\n  const op = expression.operator;\n  const length = expression.args.length;\n  const args = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    args[i] = compileExpression(expression.args[i], context);\n  }\n  switch (op) {\n    case Ops.Multiply:\n      {\n        return context => {\n          let value = 1;\n          for (let i = 0; i < length; ++i) {\n            value *= args[i](context);\n          }\n          return value;\n        };\n      }\n    case Ops.Divide:\n      {\n        return context => args[0](context) / args[1](context);\n      }\n    case Ops.Add:\n      {\n        return context => {\n          let value = 0;\n          for (let i = 0; i < length; ++i) {\n            value += args[i](context);\n          }\n          return value;\n        };\n      }\n    case Ops.Subtract:\n      {\n        return context => args[0](context) - args[1](context);\n      }\n    case Ops.Clamp:\n      {\n        return context => {\n          const value = args[0](context);\n          const min = args[1](context);\n          if (value < min) {\n            return min;\n          }\n          const max = args[2](context);\n          if (value > max) {\n            return max;\n          }\n          return value;\n        };\n      }\n    case Ops.Mod:\n      {\n        return context => args[0](context) % args[1](context);\n      }\n    case Ops.Pow:\n      {\n        return context => Math.pow(args[0](context), args[1](context));\n      }\n    case Ops.Abs:\n      {\n        return context => Math.abs(args[0](context));\n      }\n    case Ops.Floor:\n      {\n        return context => Math.floor(args[0](context));\n      }\n    case Ops.Ceil:\n      {\n        return context => Math.ceil(args[0](context));\n      }\n    case Ops.Round:\n      {\n        return context => Math.round(args[0](context));\n      }\n    case Ops.Sin:\n      {\n        return context => Math.sin(args[0](context));\n      }\n    case Ops.Cos:\n      {\n        return context => Math.cos(args[0](context));\n      }\n    case Ops.Atan:\n      {\n        if (length === 2) {\n          return context => Math.atan2(args[0](context), args[1](context));\n        }\n        return context => Math.atan(args[0](context));\n      }\n    case Ops.Sqrt:\n      {\n        return context => Math.sqrt(args[0](context));\n      }\n    default:\n      {\n        throw new Error(`Unsupported numeric operator ${op}`);\n      }\n  }\n}\n\n/**\n * @param {import('./expression.js').CallExpression} expression The call expression.\n * @param {import('./expression.js').ParsingContext} context The parsing context.\n * @return {ExpressionEvaluator} The evaluator function.\n */\nfunction compileCaseExpression(expression, context) {\n  const length = expression.args.length;\n  const args = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    args[i] = compileExpression(expression.args[i], context);\n  }\n  return context => {\n    for (let i = 0; i < length - 1; i += 2) {\n      const condition = args[i](context);\n      if (condition) {\n        return args[i + 1](context);\n      }\n    }\n    return args[length - 1](context);\n  };\n}\n\n/**\n * @param {import('./expression.js').CallExpression} expression The call expression.\n * @param {import('./expression.js').ParsingContext} context The parsing context.\n * @return {ExpressionEvaluator} The evaluator function.\n */\nfunction compileMatchExpression(expression, context) {\n  const length = expression.args.length;\n  const args = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    args[i] = compileExpression(expression.args[i], context);\n  }\n  return context => {\n    const value = args[0](context);\n    for (let i = 1; i < length; i += 2) {\n      if (value === args[i](context)) {\n        return args[i + 1](context);\n      }\n    }\n    return args[length - 1](context);\n  };\n}\n\n/**\n * @param {import('./expression.js').CallExpression} expression The call expression.\n * @param {import('./expression.js').ParsingContext} context The parsing context.\n * @return {ExpressionEvaluator} The evaluator function.\n */\nfunction compileInterpolateExpression(expression, context) {\n  const length = expression.args.length;\n  const args = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    args[i] = compileExpression(expression.args[i], context);\n  }\n  return context => {\n    const base = args[0](context);\n    const value = args[1](context);\n    let previousInput;\n    let previousOutput;\n    for (let i = 2; i < length; i += 2) {\n      const input = args[i](context);\n      let output = args[i + 1](context);\n      const isColor = Array.isArray(output);\n      if (isColor) {\n        output = withAlpha(output);\n      }\n      if (input >= value) {\n        if (i === 2) {\n          return output;\n        }\n        if (isColor) {\n          return interpolateColor(base, value, previousInput, previousOutput, input, output);\n        }\n        return interpolateNumber(base, value, previousInput, previousOutput, input, output);\n      }\n      previousInput = input;\n      previousOutput = output;\n    }\n    return previousOutput;\n  };\n}\n\n/**\n * @param {import('./expression.js').CallExpression} expression The call expression.\n * @param {import('./expression.js').ParsingContext} context The parsing context.\n * @return {ExpressionEvaluator} The evaluator function.\n */\nfunction compileConvertExpression(expression, context) {\n  const op = expression.operator;\n  const length = expression.args.length;\n  const args = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    args[i] = compileExpression(expression.args[i], context);\n  }\n  switch (op) {\n    case Ops.ToString:\n      {\n        return context => {\n          const value = args[0](context);\n          if (expression.args[0].type === ColorType) {\n            return toString(value);\n          }\n          return value.toString();\n        };\n      }\n    default:\n      {\n        throw new Error(`Unsupported convert operator ${op}`);\n      }\n  }\n}\n\n/**\n * @param {number} base The base.\n * @param {number} value The value.\n * @param {number} input1 The first input value.\n * @param {number} output1 The first output value.\n * @param {number} input2 The second input value.\n * @param {number} output2 The second output value.\n * @return {number} The interpolated value.\n */\nfunction interpolateNumber(base, value, input1, output1, input2, output2) {\n  const delta = input2 - input1;\n  if (delta === 0) {\n    return output1;\n  }\n  const along = value - input1;\n  const factor = base === 1 ? along / delta : (Math.pow(base, along) - 1) / (Math.pow(base, delta) - 1);\n  return output1 + factor * (output2 - output1);\n}\n\n/**\n * @param {number} base The base.\n * @param {number} value The value.\n * @param {number} input1 The first input value.\n * @param {import('../color.js').Color} rgba1 The first output value.\n * @param {number} input2 The second input value.\n * @param {import('../color.js').Color} rgba2 The second output value.\n * @return {import('../color.js').Color} The interpolated color.\n */\nfunction interpolateColor(base, value, input1, rgba1, input2, rgba2) {\n  const delta = input2 - input1;\n  if (delta === 0) {\n    return rgba1;\n  }\n  const lcha1 = rgbaToLcha(rgba1);\n  const lcha2 = rgbaToLcha(rgba2);\n  let deltaHue = lcha2[2] - lcha1[2];\n  if (deltaHue > 180) {\n    deltaHue -= 360;\n  } else if (deltaHue < -180) {\n    deltaHue += 360;\n  }\n  const lcha = [interpolateNumber(base, value, input1, lcha1[0], input2, lcha2[0]), interpolateNumber(base, value, input1, lcha1[1], input2, lcha2[1]), lcha1[2] + interpolateNumber(base, value, input1, 0, input2, deltaHue), interpolateNumber(base, value, input1, rgba1[3], input2, rgba2[3])];\n  return normalize(lchaToRgba(lcha));\n}", "/**\n * @module ol/render/canvas/style\n */\n\nimport Circle from '../../style/Circle.js';\nimport Fill from '../../style/Fill.js';\nimport Icon from '../../style/Icon.js';\nimport RegularShape from '../../style/RegularShape.js';\nimport Stroke from '../../style/Stroke.js';\nimport Style from '../../style/Style.js';\nimport Text from '../../style/Text.js';\nimport { BooleanType, ColorType, NumberArrayType, NumberType, StringType, computeGeometryType, newParsingContext } from '../../expr/expression.js';\nimport { NO_COLOR } from '../../color.js';\nimport { buildExpression, newEvaluationContext } from '../../expr/cpu.js';\nimport { isEmpty } from '../../obj.js';\nimport { toSize } from '../../size.js';\n\n/**\n * @fileoverview This module includes functions to build styles for the canvas renderer.  Building\n * is composed of two steps: parsing and compiling.  The parsing step takes an encoded expression\n * and returns an instance of one of the expression classes.  The compiling step takes the\n * expression instance and returns a function that can be evaluated to return a literal value.  The\n * evaluator function should do as little allocation and work as possible.\n */\n\n/**\n * @typedef {import(\"../../style/flat.js\").FlatStyle} FlatStyle\n */\n\n/**\n * @typedef {import(\"../../expr/expression.js\").EncodedExpression} EncodedExpression\n */\n\n/**\n * @typedef {import(\"../../expr/expression.js\").ParsingContext} ParsingContext\n */\n\n/**\n * @typedef {import(\"../../expr/expression.js\").CallExpression} CallExpression\n */\n\n/**\n * @typedef {import(\"../../expr/cpu.js\").EvaluationContext} EvaluationContext\n */\n\n/**\n * @typedef {import(\"../../expr/cpu.js\").ExpressionEvaluator} ExpressionEvaluator\n */\n\n/**\n * @param {EvaluationContext} context The evaluation context.\n * @return {boolean} Always true.\n */\nfunction always(context) {\n  return true;\n}\n\n/**\n * This function adapts a rule evaluator to the existing style function interface.\n * After we have deprecated the style function, we can use the compiled rules directly\n * and pass a more complete evaluation context (variables, zoom, time, etc.).\n *\n * @param {Array<import('../../style/flat.js').Rule>} rules The rules.\n * @return {import('../../style/Style.js').StyleFunction} A style function.\n */\nexport function rulesToStyleFunction(rules) {\n  const parsingContext = newParsingContext();\n  const evaluator = buildRuleSet(rules, parsingContext);\n  const evaluationContext = newEvaluationContext();\n  return function (feature, resolution) {\n    evaluationContext.properties = feature.getPropertiesInternal();\n    evaluationContext.resolution = resolution;\n    if (parsingContext.featureId) {\n      const id = feature.getId();\n      if (id !== undefined) {\n        evaluationContext.featureId = id;\n      } else {\n        evaluationContext.featureId = null;\n      }\n    }\n    if (parsingContext.geometryType) {\n      evaluationContext.geometryType = computeGeometryType(feature.getGeometry());\n    }\n    return evaluator(evaluationContext);\n  };\n}\n\n/**\n * This function adapts a style evaluator to the existing style function interface.\n * After we have deprecated the style function, we can use the compiled rules directly\n * and pass a more complete evaluation context (variables, zoom, time, etc.).\n *\n * @param {Array<import('../../style/flat.js').FlatStyle>} flatStyles The flat styles.\n * @return {import('../../style/Style.js').StyleFunction} A style function.\n */\nexport function flatStylesToStyleFunction(flatStyles) {\n  const parsingContext = newParsingContext();\n  const length = flatStyles.length;\n\n  /**\n   * @type {Array<StyleEvaluator>}\n   */\n  const evaluators = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    evaluators[i] = buildStyle(flatStyles[i], parsingContext);\n  }\n  const evaluationContext = newEvaluationContext();\n\n  /**\n   * @type {Array<Style>}\n   */\n  const styles = new Array(length);\n  return function (feature, resolution) {\n    evaluationContext.properties = feature.getPropertiesInternal();\n    evaluationContext.resolution = resolution;\n    if (parsingContext.featureId) {\n      const id = feature.getId();\n      if (id !== undefined) {\n        evaluationContext.featureId = id;\n      } else {\n        evaluationContext.featureId = null;\n      }\n    }\n    let nonNullCount = 0;\n    for (let i = 0; i < length; ++i) {\n      const style = evaluators[i](evaluationContext);\n      if (style) {\n        styles[nonNullCount] = style;\n        nonNullCount += 1;\n      }\n    }\n    styles.length = nonNullCount;\n    return styles;\n  };\n}\n\n/**\n * @typedef {function(EvaluationContext):Array<Style>} RuleSetEvaluator\n */\n\n/**\n * @typedef {Object} CompiledRule\n * @property {ExpressionEvaluator} filter The compiled filter evaluator.\n * @property {Array<StyleEvaluator>} styles The list of compiled style evaluators.\n */\n\n/**\n * @param {Array<import('../../style/flat.js').Rule>} rules The rules.\n * @param {ParsingContext} context The parsing context.\n * @return {RuleSetEvaluator} The evaluator function.\n */\nexport function buildRuleSet(rules, context) {\n  const length = rules.length;\n\n  /**\n   * @type {Array<CompiledRule>}\n   */\n  const compiledRules = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    const rule = rules[i];\n    const filter = 'filter' in rule ? buildExpression(rule.filter, BooleanType, context) : always;\n\n    /**\n     * @type {Array<StyleEvaluator>}\n     */\n    let styles;\n    if (Array.isArray(rule.style)) {\n      const styleLength = rule.style.length;\n      styles = new Array(styleLength);\n      for (let j = 0; j < styleLength; ++j) {\n        styles[j] = buildStyle(rule.style[j], context);\n      }\n    } else {\n      styles = [buildStyle(rule.style, context)];\n    }\n    compiledRules[i] = {\n      filter,\n      styles\n    };\n  }\n  return function (context) {\n    /**\n     * @type {Array<Style>}\n     */\n    const styles = [];\n    let someMatched = false;\n    for (let i = 0; i < length; ++i) {\n      const filterEvaluator = compiledRules[i].filter;\n      if (!filterEvaluator(context)) {\n        continue;\n      }\n      if (rules[i].else && someMatched) {\n        continue;\n      }\n      someMatched = true;\n      for (const styleEvaluator of compiledRules[i].styles) {\n        const style = styleEvaluator(context);\n        if (!style) {\n          continue;\n        }\n        styles.push(style);\n      }\n    }\n    return styles;\n  };\n}\n\n/**\n * @typedef {function(EvaluationContext):Style|null} StyleEvaluator\n */\n\n/**\n * @param {FlatStyle} flatStyle A flat style literal.\n * @param {ParsingContext} context The parsing context.\n * @return {StyleEvaluator} A function that evaluates to a style.  The style returned by\n * this function will be reused between invocations.\n */\nexport function buildStyle(flatStyle, context) {\n  const evaluateFill = buildFill(flatStyle, '', context);\n  const evaluateStroke = buildStroke(flatStyle, '', context);\n  const evaluateText = buildText(flatStyle, context);\n  const evaluateImage = buildImage(flatStyle, context);\n  const evaluateZIndex = numberEvaluator(flatStyle, 'z-index', context);\n  if (!evaluateFill && !evaluateStroke && !evaluateText && !evaluateImage && !isEmpty(flatStyle)) {\n    // assume this is a user error\n    // would be nice to check the properties and suggest \"did you mean...\"\n    throw new Error('No fill, stroke, point, or text symbolizer properties in style: ' + JSON.stringify(flatStyle));\n  }\n  const style = new Style();\n  return function (context) {\n    let empty = true;\n    if (evaluateFill) {\n      const fill = evaluateFill(context);\n      if (fill) {\n        empty = false;\n      }\n      style.setFill(fill);\n    }\n    if (evaluateStroke) {\n      const stroke = evaluateStroke(context);\n      if (stroke) {\n        empty = false;\n      }\n      style.setStroke(stroke);\n    }\n    if (evaluateText) {\n      const text = evaluateText(context);\n      if (text) {\n        empty = false;\n      }\n      style.setText(text);\n    }\n    if (evaluateImage) {\n      const image = evaluateImage(context);\n      if (image) {\n        empty = false;\n      }\n      style.setImage(image);\n    }\n    if (evaluateZIndex) {\n      style.setZIndex(evaluateZIndex(context));\n    }\n    if (empty) {\n      return null;\n    }\n    return style;\n  };\n}\n\n/**\n * @typedef {function(EvaluationContext):Fill|null} FillEvaluator\n */\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} prefix The property prefix.\n * @param {ParsingContext} context The parsing context.\n * @return {FillEvaluator?} A function that evaluates to a fill.\n */\nfunction buildFill(flatStyle, prefix, context) {\n  let evaluateColor;\n  if (prefix + 'fill-pattern-src' in flatStyle) {\n    evaluateColor = patternEvaluator(flatStyle, prefix + 'fill-', context);\n  } else {\n    if (flatStyle[prefix + 'fill-color'] === 'none') {\n      // avoids hit detection\n      return context => null;\n    }\n    evaluateColor = colorLikeEvaluator(flatStyle, prefix + 'fill-color', context);\n  }\n  if (!evaluateColor) {\n    return null;\n  }\n  const fill = new Fill();\n  return function (context) {\n    const color = evaluateColor(context);\n    if (color === NO_COLOR) {\n      return null;\n    }\n    fill.setColor(color);\n    return fill;\n  };\n}\n\n/**\n * @typedef {function(EvaluationContext):Stroke|null} StrokeEvaluator\n */\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} prefix The property prefix.\n * @param {ParsingContext} context The parsing context.\n * @return {StrokeEvaluator?} A function the evaluates to a stroke.\n */\nfunction buildStroke(flatStyle, prefix, context) {\n  const evaluateWidth = numberEvaluator(flatStyle, prefix + 'stroke-width', context);\n  const evaluateColor = colorLikeEvaluator(flatStyle, prefix + 'stroke-color', context);\n  if (!evaluateWidth && !evaluateColor) {\n    return null;\n  }\n  const evaluateLineCap = stringEvaluator(flatStyle, prefix + 'stroke-line-cap', context);\n  const evaluateLineJoin = stringEvaluator(flatStyle, prefix + 'stroke-line-join', context);\n  const evaluateLineDash = numberArrayEvaluator(flatStyle, prefix + 'stroke-line-dash', context);\n  const evaluateLineDashOffset = numberEvaluator(flatStyle, prefix + 'stroke-line-dash-offset', context);\n  const evaluateMiterLimit = numberEvaluator(flatStyle, prefix + 'stroke-miter-limit', context);\n  const stroke = new Stroke();\n  return function (context) {\n    if (evaluateColor) {\n      const color = evaluateColor(context);\n      if (color === NO_COLOR) {\n        return null;\n      }\n      stroke.setColor(color);\n    }\n    if (evaluateWidth) {\n      stroke.setWidth(evaluateWidth(context));\n    }\n    if (evaluateLineCap) {\n      const lineCap = evaluateLineCap(context);\n      if (lineCap !== 'butt' && lineCap !== 'round' && lineCap !== 'square') {\n        throw new Error('Expected butt, round, or square line cap');\n      }\n      stroke.setLineCap(lineCap);\n    }\n    if (evaluateLineJoin) {\n      const lineJoin = evaluateLineJoin(context);\n      if (lineJoin !== 'bevel' && lineJoin !== 'round' && lineJoin !== 'miter') {\n        throw new Error('Expected bevel, round, or miter line join');\n      }\n      stroke.setLineJoin(lineJoin);\n    }\n    if (evaluateLineDash) {\n      stroke.setLineDash(evaluateLineDash(context));\n    }\n    if (evaluateLineDashOffset) {\n      stroke.setLineDashOffset(evaluateLineDashOffset(context));\n    }\n    if (evaluateMiterLimit) {\n      stroke.setMiterLimit(evaluateMiterLimit(context));\n    }\n    return stroke;\n  };\n}\n\n/**\n * @typedef {function(EvaluationContext):Text} TextEvaluator\n */\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {ParsingContext} context The parsing context.\n * @return {TextEvaluator?} A function that evaluates to a text symbolizer.\n */\nfunction buildText(flatStyle, context) {\n  const prefix = 'text-';\n\n  // Currently, an Array<string> may be used for rich text support.  This doesn't\n  // work with our expression syntax where arrays of strings are interpreted as\n  // call expressions.  To support rich text, we could add a 'strings' operator\n  // where all the following arguments would be string values.\n  const evaluateValue = stringEvaluator(flatStyle, prefix + 'value', context);\n  if (!evaluateValue) {\n    return null;\n  }\n  const evaluateFill = buildFill(flatStyle, prefix, context);\n  const evaluateBackgroundFill = buildFill(flatStyle, prefix + 'background-', context);\n  const evaluateStroke = buildStroke(flatStyle, prefix, context);\n  const evaluateBackgroundStroke = buildStroke(flatStyle, prefix + 'background-', context);\n  const evaluateFont = stringEvaluator(flatStyle, prefix + 'font', context);\n  const evaluateMaxAngle = numberEvaluator(flatStyle, prefix + 'max-angle', context);\n  const evaluateOffsetX = numberEvaluator(flatStyle, prefix + 'offset-x', context);\n  const evaluateOffsetY = numberEvaluator(flatStyle, prefix + 'offset-y', context);\n  const evaluateOverflow = booleanEvaluator(flatStyle, prefix + 'overflow', context);\n  const evaluatePlacement = stringEvaluator(flatStyle, prefix + 'placement', context);\n  const evaluateRepeat = numberEvaluator(flatStyle, prefix + 'repeat', context);\n  const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + 'scale', context);\n  const evaluateRotateWithView = booleanEvaluator(flatStyle, prefix + 'rotate-with-view', context);\n  const evaluateRotation = numberEvaluator(flatStyle, prefix + 'rotation', context);\n  const evaluateAlign = stringEvaluator(flatStyle, prefix + 'align', context);\n  const evaluateJustify = stringEvaluator(flatStyle, prefix + 'justify', context);\n  const evaluateBaseline = stringEvaluator(flatStyle, prefix + 'baseline', context);\n  const evaluateKeepUpright = booleanEvaluator(flatStyle, prefix + 'keep-upright', context);\n  const evaluatePadding = numberArrayEvaluator(flatStyle, prefix + 'padding', context);\n\n  // The following properties are not currently settable\n  const declutterMode = optionalDeclutterMode(flatStyle, prefix + 'declutter-mode');\n  const text = new Text({\n    declutterMode\n  });\n  return function (context) {\n    text.setText(evaluateValue(context));\n    if (evaluateFill) {\n      text.setFill(evaluateFill(context));\n    }\n    if (evaluateBackgroundFill) {\n      text.setBackgroundFill(evaluateBackgroundFill(context));\n    }\n    if (evaluateStroke) {\n      text.setStroke(evaluateStroke(context));\n    }\n    if (evaluateBackgroundStroke) {\n      text.setBackgroundStroke(evaluateBackgroundStroke(context));\n    }\n    if (evaluateFont) {\n      text.setFont(evaluateFont(context));\n    }\n    if (evaluateMaxAngle) {\n      text.setMaxAngle(evaluateMaxAngle(context));\n    }\n    if (evaluateOffsetX) {\n      text.setOffsetX(evaluateOffsetX(context));\n    }\n    if (evaluateOffsetY) {\n      text.setOffsetY(evaluateOffsetY(context));\n    }\n    if (evaluateOverflow) {\n      text.setOverflow(evaluateOverflow(context));\n    }\n    if (evaluatePlacement) {\n      const placement = evaluatePlacement(context);\n      if (placement !== 'point' && placement !== 'line') {\n        throw new Error('Expected point or line for text-placement');\n      }\n      text.setPlacement(placement);\n    }\n    if (evaluateRepeat) {\n      text.setRepeat(evaluateRepeat(context));\n    }\n    if (evaluateScale) {\n      text.setScale(evaluateScale(context));\n    }\n    if (evaluateRotateWithView) {\n      text.setRotateWithView(evaluateRotateWithView(context));\n    }\n    if (evaluateRotation) {\n      text.setRotation(evaluateRotation(context));\n    }\n    if (evaluateAlign) {\n      const textAlign = evaluateAlign(context);\n      if (textAlign !== 'left' && textAlign !== 'center' && textAlign !== 'right' && textAlign !== 'end' && textAlign !== 'start') {\n        throw new Error('Expected left, right, center, start, or end for text-align');\n      }\n      text.setTextAlign(textAlign);\n    }\n    if (evaluateJustify) {\n      const justify = evaluateJustify(context);\n      if (justify !== 'left' && justify !== 'right' && justify !== 'center') {\n        throw new Error('Expected left, right, or center for text-justify');\n      }\n      text.setJustify(justify);\n    }\n    if (evaluateBaseline) {\n      const textBaseline = evaluateBaseline(context);\n      if (textBaseline !== 'bottom' && textBaseline !== 'top' && textBaseline !== 'middle' && textBaseline !== 'alphabetic' && textBaseline !== 'hanging') {\n        throw new Error('Expected bottom, top, middle, alphabetic, or hanging for text-baseline');\n      }\n      text.setTextBaseline(textBaseline);\n    }\n    if (evaluatePadding) {\n      text.setPadding(evaluatePadding(context));\n    }\n    if (evaluateKeepUpright) {\n      text.setKeepUpright(evaluateKeepUpright(context));\n    }\n    return text;\n  };\n}\n\n/**\n * @typedef {function(EvaluationContext):import(\"../../style/Image.js\").default} ImageEvaluator\n */\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {ParsingContext} context The parsing context.\n * @return {ImageEvaluator?} A function that evaluates to an image symbolizer.\n */\nfunction buildImage(flatStyle, context) {\n  if ('icon-src' in flatStyle) {\n    return buildIcon(flatStyle, context);\n  }\n  if ('shape-points' in flatStyle) {\n    return buildShape(flatStyle, context);\n  }\n  if ('circle-radius' in flatStyle) {\n    return buildCircle(flatStyle, context);\n  }\n  return null;\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {ParsingContext} context The parsing context.\n * @return {ImageEvaluator} A function that evaluates to an image symbolizer.\n */\nfunction buildIcon(flatStyle, context) {\n  const prefix = 'icon-';\n\n  // required property\n  const srcName = prefix + 'src';\n  const src = requireString(flatStyle[srcName], srcName);\n\n  // settable properties\n  const evaluateAnchor = coordinateEvaluator(flatStyle, prefix + 'anchor', context);\n  const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + 'scale', context);\n  const evaluateOpacity = numberEvaluator(flatStyle, prefix + 'opacity', context);\n  const evaluateDisplacement = coordinateEvaluator(flatStyle, prefix + 'displacement', context);\n  const evaluateRotation = numberEvaluator(flatStyle, prefix + 'rotation', context);\n  const evaluateRotateWithView = booleanEvaluator(flatStyle, prefix + 'rotate-with-view', context);\n\n  // the remaining symbolizer properties are not currently settable\n  const anchorOrigin = optionalIconOrigin(flatStyle, prefix + 'anchor-origin');\n  const anchorXUnits = optionalIconAnchorUnits(flatStyle, prefix + 'anchor-x-units');\n  const anchorYUnits = optionalIconAnchorUnits(flatStyle, prefix + 'anchor-y-units');\n  const color = optionalColorLike(flatStyle, prefix + 'color');\n  const crossOrigin = optionalString(flatStyle, prefix + 'cross-origin');\n  const offset = optionalNumberArray(flatStyle, prefix + 'offset');\n  const offsetOrigin = optionalIconOrigin(flatStyle, prefix + 'offset-origin');\n  const width = optionalNumber(flatStyle, prefix + 'width');\n  const height = optionalNumber(flatStyle, prefix + 'height');\n  const size = optionalSize(flatStyle, prefix + 'size');\n  const declutterMode = optionalDeclutterMode(flatStyle, prefix + 'declutter-mode');\n  const icon = new Icon({\n    src,\n    anchorOrigin,\n    anchorXUnits,\n    anchorYUnits,\n    color,\n    crossOrigin,\n    offset,\n    offsetOrigin,\n    height,\n    width,\n    size,\n    declutterMode\n  });\n  return function (context) {\n    if (evaluateOpacity) {\n      icon.setOpacity(evaluateOpacity(context));\n    }\n    if (evaluateDisplacement) {\n      icon.setDisplacement(evaluateDisplacement(context));\n    }\n    if (evaluateRotation) {\n      icon.setRotation(evaluateRotation(context));\n    }\n    if (evaluateRotateWithView) {\n      icon.setRotateWithView(evaluateRotateWithView(context));\n    }\n    if (evaluateScale) {\n      icon.setScale(evaluateScale(context));\n    }\n    if (evaluateAnchor) {\n      icon.setAnchor(evaluateAnchor(context));\n    }\n    return icon;\n  };\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {ParsingContext} context The parsing context.\n * @return {ImageEvaluator} A function that evaluates to an icon symbolizer.\n */\nfunction buildShape(flatStyle, context) {\n  const prefix = 'shape-';\n\n  // required property\n  const pointsName = prefix + 'points';\n  const radiusName = prefix + 'radius';\n  const points = requireNumber(flatStyle[pointsName], pointsName);\n  const radius = requireNumber(flatStyle[radiusName], radiusName);\n\n  // settable properties\n  const evaluateFill = buildFill(flatStyle, prefix, context);\n  const evaluateStroke = buildStroke(flatStyle, prefix, context);\n  const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + 'scale', context);\n  const evaluateDisplacement = coordinateEvaluator(flatStyle, prefix + 'displacement', context);\n  const evaluateRotation = numberEvaluator(flatStyle, prefix + 'rotation', context);\n  const evaluateRotateWithView = booleanEvaluator(flatStyle, prefix + 'rotate-with-view', context);\n\n  // the remaining properties are not currently settable\n  const radius2 = optionalNumber(flatStyle, prefix + 'radius2');\n  const angle = optionalNumber(flatStyle, prefix + 'angle');\n  const declutterMode = optionalDeclutterMode(flatStyle, prefix + 'declutter-mode');\n  const shape = new RegularShape({\n    points,\n    radius,\n    radius2,\n    angle,\n    declutterMode\n  });\n  return function (context) {\n    if (evaluateFill) {\n      shape.setFill(evaluateFill(context));\n    }\n    if (evaluateStroke) {\n      shape.setStroke(evaluateStroke(context));\n    }\n    if (evaluateDisplacement) {\n      shape.setDisplacement(evaluateDisplacement(context));\n    }\n    if (evaluateRotation) {\n      shape.setRotation(evaluateRotation(context));\n    }\n    if (evaluateRotateWithView) {\n      shape.setRotateWithView(evaluateRotateWithView(context));\n    }\n    if (evaluateScale) {\n      shape.setScale(evaluateScale(context));\n    }\n    return shape;\n  };\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {ParsingContext} context The parsing context.\n * @return {ImageEvaluator} A function that evaluates to a circle symbolizer.\n */\nfunction buildCircle(flatStyle, context) {\n  const prefix = 'circle-';\n\n  // settable properties\n  const evaluateFill = buildFill(flatStyle, prefix, context);\n  const evaluateStroke = buildStroke(flatStyle, prefix, context);\n  const evaluateRadius = numberEvaluator(flatStyle, prefix + 'radius', context);\n  const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + 'scale', context);\n  const evaluateDisplacement = coordinateEvaluator(flatStyle, prefix + 'displacement', context);\n  const evaluateRotation = numberEvaluator(flatStyle, prefix + 'rotation', context);\n  const evaluateRotateWithView = booleanEvaluator(flatStyle, prefix + 'rotate-with-view', context);\n\n  // the remaining properties are not currently settable\n  const declutterMode = optionalDeclutterMode(flatStyle, prefix + 'declutter-mode');\n  const circle = new Circle({\n    radius: 5,\n    // this is arbitrary, but required - the evaluated radius is used below\n    declutterMode\n  });\n  return function (context) {\n    if (evaluateRadius) {\n      circle.setRadius(evaluateRadius(context));\n    }\n    if (evaluateFill) {\n      circle.setFill(evaluateFill(context));\n    }\n    if (evaluateStroke) {\n      circle.setStroke(evaluateStroke(context));\n    }\n    if (evaluateDisplacement) {\n      circle.setDisplacement(evaluateDisplacement(context));\n    }\n    if (evaluateRotation) {\n      circle.setRotation(evaluateRotation(context));\n    }\n    if (evaluateRotateWithView) {\n      circle.setRotateWithView(evaluateRotateWithView(context));\n    }\n    if (evaluateScale) {\n      circle.setScale(evaluateScale(context));\n    }\n    return circle;\n  };\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} name The property name.\n * @param {ParsingContext} context The parsing context.\n * @return {import('../../expr/cpu.js').NumberEvaluator|undefined} The expression evaluator or undefined.\n */\nfunction numberEvaluator(flatStyle, name, context) {\n  if (!(name in flatStyle)) {\n    return undefined;\n  }\n  const evaluator = buildExpression(flatStyle[name], NumberType, context);\n  return function (context) {\n    return requireNumber(evaluator(context), name);\n  };\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} name The property name.\n * @param {ParsingContext} context The parsing context.\n * @return {import('../../expr/cpu.js').StringEvaluator?} The expression evaluator.\n */\nfunction stringEvaluator(flatStyle, name, context) {\n  if (!(name in flatStyle)) {\n    return null;\n  }\n  const evaluator = buildExpression(flatStyle[name], StringType, context);\n  return function (context) {\n    return requireString(evaluator(context), name);\n  };\n}\nfunction patternEvaluator(flatStyle, prefix, context) {\n  const srcEvaluator = stringEvaluator(flatStyle, prefix + 'pattern-src', context);\n  const offsetEvaluator = sizeEvaluator(flatStyle, prefix + 'pattern-offset', context);\n  const patternSizeEvaluator = sizeEvaluator(flatStyle, prefix + 'pattern-size', context);\n  const colorEvaluator = colorLikeEvaluator(flatStyle, prefix + 'color', context);\n  return function (context) {\n    return {\n      src: srcEvaluator(context),\n      offset: offsetEvaluator && offsetEvaluator(context),\n      size: patternSizeEvaluator && patternSizeEvaluator(context),\n      color: colorEvaluator && colorEvaluator(context)\n    };\n  };\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} name The property name.\n * @param {ParsingContext} context The parsing context.\n * @return {import('../../expr/cpu.js').BooleanEvaluator?} The expression evaluator.\n */\nfunction booleanEvaluator(flatStyle, name, context) {\n  if (!(name in flatStyle)) {\n    return null;\n  }\n  const evaluator = buildExpression(flatStyle[name], BooleanType, context);\n  return function (context) {\n    const value = evaluator(context);\n    if (typeof value !== 'boolean') {\n      throw new Error(`Expected a boolean for ${name}`);\n    }\n    return value;\n  };\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} name The property name.\n * @param {ParsingContext} context The parsing context.\n * @return {import('../../expr/cpu.js').ColorLikeEvaluator?} The expression evaluator.\n */\nfunction colorLikeEvaluator(flatStyle, name, context) {\n  if (!(name in flatStyle)) {\n    return null;\n  }\n  const evaluator = buildExpression(flatStyle[name], ColorType, context);\n  return function (context) {\n    return requireColorLike(evaluator(context), name);\n  };\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} name The property name.\n * @param {ParsingContext} context The parsing context.\n * @return {import('../../expr/cpu.js').NumberArrayEvaluator?} The expression evaluator.\n */\nfunction numberArrayEvaluator(flatStyle, name, context) {\n  if (!(name in flatStyle)) {\n    return null;\n  }\n  const evaluator = buildExpression(flatStyle[name], NumberArrayType, context);\n  return function (context) {\n    return requireNumberArray(evaluator(context), name);\n  };\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} name The property name.\n * @param {ParsingContext} context The parsing context.\n * @return {import('../../expr/cpu.js').CoordinateEvaluator?} The expression evaluator.\n */\nfunction coordinateEvaluator(flatStyle, name, context) {\n  if (!(name in flatStyle)) {\n    return null;\n  }\n  const evaluator = buildExpression(flatStyle[name], NumberArrayType, context);\n  return function (context) {\n    const array = requireNumberArray(evaluator(context), name);\n    if (array.length !== 2) {\n      throw new Error(`Expected two numbers for ${name}`);\n    }\n    return array;\n  };\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} name The property name.\n * @param {ParsingContext} context The parsing context.\n * @return {import('../../expr/cpu.js').SizeEvaluator?} The expression evaluator.\n */\nfunction sizeEvaluator(flatStyle, name, context) {\n  if (!(name in flatStyle)) {\n    return null;\n  }\n  const evaluator = buildExpression(flatStyle[name], NumberArrayType, context);\n  return function (context) {\n    return requireSize(evaluator(context), name);\n  };\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} name The property name.\n * @param {ParsingContext} context The parsing context.\n * @return {import('../../expr/cpu.js').SizeLikeEvaluator?} The expression evaluator.\n */\nfunction sizeLikeEvaluator(flatStyle, name, context) {\n  if (!(name in flatStyle)) {\n    return null;\n  }\n  const evaluator = buildExpression(flatStyle[name], NumberArrayType | NumberType, context);\n  return function (context) {\n    return requireSizeLike(evaluator(context), name);\n  };\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} property The symbolizer property.\n * @return {number|undefined} A number or undefined.\n */\nfunction optionalNumber(flatStyle, property) {\n  const value = flatStyle[property];\n  if (value === undefined) {\n    return undefined;\n  }\n  if (typeof value !== 'number') {\n    throw new Error(`Expected a number for ${property}`);\n  }\n  return value;\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} property The symbolizer property.\n * @return {import(\"../../size.js\").Size|undefined} A size or undefined.\n */\nfunction optionalSize(flatStyle, property) {\n  const encoded = flatStyle[property];\n  if (encoded === undefined) {\n    return undefined;\n  }\n  if (typeof encoded === 'number') {\n    return toSize(encoded);\n  }\n  if (!Array.isArray(encoded)) {\n    throw new Error(`Expected a number or size array for ${property}`);\n  }\n  if (encoded.length !== 2 || typeof encoded[0] !== 'number' || typeof encoded[1] !== 'number') {\n    throw new Error(`Expected a number or size array for ${property}`);\n  }\n  return encoded;\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} property The symbolizer property.\n * @return {string|undefined} A string or undefined.\n */\nfunction optionalString(flatStyle, property) {\n  const encoded = flatStyle[property];\n  if (encoded === undefined) {\n    return undefined;\n  }\n  if (typeof encoded !== 'string') {\n    throw new Error(`Expected a string for ${property}`);\n  }\n  return encoded;\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} property The symbolizer property.\n * @return {import(\"../../style/Icon.js\").IconOrigin|undefined} An icon origin or undefined.\n */\nfunction optionalIconOrigin(flatStyle, property) {\n  const encoded = flatStyle[property];\n  if (encoded === undefined) {\n    return undefined;\n  }\n  if (encoded !== 'bottom-left' && encoded !== 'bottom-right' && encoded !== 'top-left' && encoded !== 'top-right') {\n    throw new Error(`Expected bottom-left, bottom-right, top-left, or top-right for ${property}`);\n  }\n  return encoded;\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} property The symbolizer property.\n * @return {import(\"../../style/Icon.js\").IconAnchorUnits|undefined} Icon anchor units or undefined.\n */\nfunction optionalIconAnchorUnits(flatStyle, property) {\n  const encoded = flatStyle[property];\n  if (encoded === undefined) {\n    return undefined;\n  }\n  if (encoded !== 'pixels' && encoded !== 'fraction') {\n    throw new Error(`Expected pixels or fraction for ${property}`);\n  }\n  return encoded;\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} property The symbolizer property.\n * @return {Array<number>|undefined} An array of numbers or undefined.\n */\nfunction optionalNumberArray(flatStyle, property) {\n  const encoded = flatStyle[property];\n  if (encoded === undefined) {\n    return undefined;\n  }\n  return requireNumberArray(encoded, property);\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} property The symbolizer property.\n * @return {import('../../style/Style.js').DeclutterMode} Icon declutter mode.\n */\nfunction optionalDeclutterMode(flatStyle, property) {\n  const encoded = flatStyle[property];\n  if (encoded === undefined) {\n    return undefined;\n  }\n  if (typeof encoded !== 'string') {\n    throw new Error(`Expected a string for ${property}`);\n  }\n  if (encoded !== 'declutter' && encoded !== 'obstacle' && encoded !== 'none') {\n    throw new Error(`Expected declutter, obstacle, or none for ${property}`);\n  }\n  return encoded;\n}\n\n/**\n * @param {FlatStyle} flatStyle The flat style.\n * @param {string} property The symbolizer property.\n * @return {string|Array<number>|undefined} A string or an array of color values or undefined.\n */\nfunction optionalColorLike(flatStyle, property) {\n  const encoded = flatStyle[property];\n  if (encoded === undefined) {\n    return undefined;\n  }\n  return requireColorLike(encoded, property);\n}\n\n/**\n * @param {any} value The value.\n * @param {string} property The property.\n * @return {Array<number>} An array of numbers.\n */\nfunction requireNumberArray(value, property) {\n  if (!Array.isArray(value)) {\n    throw new Error(`Expected an array for ${property}`);\n  }\n  const length = value.length;\n  for (let i = 0; i < length; ++i) {\n    if (typeof value[i] !== 'number') {\n      throw new Error(`Expected an array of numbers for ${property}`);\n    }\n  }\n  return value;\n}\n\n/**\n * @param {any} value The value.\n * @param {string} property The property.\n * @return {string} A string.\n */\nfunction requireString(value, property) {\n  if (typeof value !== 'string') {\n    throw new Error(`Expected a string for ${property}`);\n  }\n  return value;\n}\n\n/**\n * @param {any} value The value.\n * @param {string} property The property.\n * @return {number} A number.\n */\nfunction requireNumber(value, property) {\n  if (typeof value !== 'number') {\n    throw new Error(`Expected a number for ${property}`);\n  }\n  return value;\n}\n\n/**\n * @param {any} value The value.\n * @param {string} property The property.\n * @return {Array<number>|string} A color.\n */\nfunction requireColorLike(value, property) {\n  if (typeof value === 'string') {\n    return value;\n  }\n  const array = requireNumberArray(value, property);\n  const length = array.length;\n  if (length < 3 || length > 4) {\n    throw new Error(`Expected a color with 3 or 4 values for ${property}`);\n  }\n  return array;\n}\n\n/**\n * @param {any} value The value.\n * @param {string} property The property.\n * @return {Array<number>} A number or an array of two numbers.\n */\nfunction requireSize(value, property) {\n  const size = requireNumberArray(value, property);\n  if (size.length !== 2) {\n    throw new Error(`Expected an array of two numbers for ${property}`);\n  }\n  return size;\n}\n\n/**\n * @param {any} value The value.\n * @param {string} property The property.\n * @return {number|Array<number>} A number or an array of two numbers.\n */\nfunction requireSizeLike(value, property) {\n  if (typeof value === 'number') {\n    return value;\n  }\n  return requireSize(value, property);\n}", "/**\n * @module ol/layer/BaseVector\n */\nimport Layer from './Layer.js';\nimport RBush from 'rbush';\nimport Style, { createDefaultStyle, toFunction as toStyleFunction } from '../style/Style.js';\nimport { flatStylesToStyleFunction, rulesToStyleFunction } from '../render/canvas/style.js';\n\n/***\n * @template T\n * @typedef {T extends import(\"../source/Vector.js\").default<infer U extends import(\"../Feature.js\").FeatureLike> ? U : never} ExtractedFeatureType\n */\n\n/**\n * @template {import('../Feature').FeatureLike} FeatureType\n * @template {import(\"../source/Vector.js\").default<FeatureType>|import(\"../source/VectorTile.js\").default<FeatureType>} VectorSourceType<FeatureType>\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\n * visible.\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\n * be visible.\n * @property {import(\"../render.js\").OrderFunction} [renderOrder] Render order. Function to be used when sorting\n * features before rendering. By default features are drawn in the order that they are created. Use\n * `null` to avoid the sort, but get an undefined draw order.\n * @property {number} [renderBuffer=100] The buffer in pixels around the viewport extent used by the\n * renderer when getting features from the vector source for the rendering or hit-detection.\n * Recommended value: the size of the largest symbol, line width or label.\n * @property {VectorSourceType} [source] Source.\n * @property {import(\"../Map.js\").default} [map] Sets the layer as overlay on a map. The map will not manage\n * this layer in its layers collection, and the layer will be rendered on top. This is useful for\n * temporary layers. The standard way to add a layer to a map and have it managed by the map is to\n * use [map.addLayer()]{@link import(\"../Map.js\").default#addLayer}.\n * @property {boolean|string|number} [declutter=false] Declutter images and text. Any truthy value will enable\n * decluttering. Within a layer, a feature rendered before another has higher priority. All layers with the\n * same `declutter` value will be decluttered together. The priority is determined by the drawing order of the\n * layers with the same `declutter` value. Higher in the layer stack means higher priority. To declutter distinct\n * layers or groups of layers separately, use different truthy values for `declutter`.\n * @property {import(\"../style/Style.js\").StyleLike|import(\"../style/flat.js\").FlatStyleLike|null} [style] Layer style. When set to `null`, only\n * features that have their own style will be rendered. See {@link module:ol/style/Style~Style} for the default style\n * which will be used if this is not set.\n * @property {import(\"./Base.js\").BackgroundColor} [background] Background color for the layer. If not specified, no background\n * will be rendered.\n * @property {boolean} [updateWhileAnimating=false] When set to `true`, feature batches will\n * be recreated during animations. This means that no vectors will be shown clipped, but the\n * setting will have a performance impact for large amounts of vector data. When set to `false`,\n * batches will be recreated when no animation is active.\n * @property {boolean} [updateWhileInteracting=false] When set to `true`, feature batches will\n * be recreated during interactions. See also `updateWhileAnimating`.\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\n */\n\n/**\n * @enum {string}\n * @private\n */\nconst Property = {\n  RENDER_ORDER: 'renderOrder'\n};\n\n/**\n * @classdesc\n * Vector data that is rendered client-side.\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\n * property on the layer object; for example, setting `title: 'My Title'` in the\n * options means that `title` is observable, and has get/set accessors.\n *\n * @template {import('../Feature').FeatureLike} FeatureType\n * @template {import(\"../source/Vector.js\").default<FeatureType>|import(\"../source/VectorTile.js\").default<FeatureType>} VectorSourceType<FeatureType>\n * @extends {Layer<VectorSourceType, RendererType>}\n * @template {import(\"../renderer/canvas/VectorLayer.js\").default|import(\"../renderer/canvas/VectorTileLayer.js\").default|import(\"../renderer/canvas/VectorImageLayer.js\").default|import(\"../renderer/webgl/PointsLayer.js\").default} RendererType\n * @api\n */\nclass BaseVectorLayer extends Layer {\n  /**\n   * @param {Options<FeatureType, VectorSourceType>} [options] Options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n    const baseOptions = Object.assign({}, options);\n    delete baseOptions.style;\n    delete baseOptions.renderBuffer;\n    delete baseOptions.updateWhileAnimating;\n    delete baseOptions.updateWhileInteracting;\n    super(baseOptions);\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.declutter_ = options.declutter ? String(options.declutter) : undefined;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.renderBuffer_ = options.renderBuffer !== undefined ? options.renderBuffer : 100;\n\n    /**\n     * User provided style.\n     * @type {import(\"../style/Style.js\").StyleLike|import(\"../style/flat.js\").FlatStyleLike}\n     * @private\n     */\n    this.style_ = null;\n\n    /**\n     * Style function for use within the library.\n     * @type {import(\"../style/Style.js\").StyleFunction|undefined}\n     * @private\n     */\n    this.styleFunction_ = undefined;\n    this.setStyle(options.style);\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.updateWhileAnimating_ = options.updateWhileAnimating !== undefined ? options.updateWhileAnimating : false;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.updateWhileInteracting_ = options.updateWhileInteracting !== undefined ? options.updateWhileInteracting : false;\n  }\n\n  /**\n   * @return {string} Declutter group.\n   * @override\n   */\n  getDeclutter() {\n    return this.declutter_;\n  }\n\n  /**\n   * Get the topmost feature that intersects the given pixel on the viewport. Returns a promise\n   * that resolves with an array of features. The array will either contain the topmost feature\n   * when a hit was detected, or it will be empty.\n   *\n   * The hit detection algorithm used for this method is optimized for performance, but is less\n   * accurate than the one used in [map.getFeaturesAtPixel()]{@link import(\"../Map.js\").default#getFeaturesAtPixel}.\n   * Text is not considered, and icons are only represented by their bounding box instead of the exact\n   * image.\n   *\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\n   * @return {Promise<Array<import(\"../Feature\").FeatureLike>>} Promise that resolves with an array of features.\n   * @api\n   * @override\n   */\n  getFeatures(pixel) {\n    return super.getFeatures(pixel);\n  }\n\n  /**\n   * @return {number|undefined} Render buffer.\n   */\n  getRenderBuffer() {\n    return this.renderBuffer_;\n  }\n\n  /**\n   * @return {function(import(\"../Feature.js\").default, import(\"../Feature.js\").default): number|null|undefined} Render\n   *     order.\n   */\n  getRenderOrder() {\n    return /** @type {import(\"../render.js\").OrderFunction|null|undefined} */this.get(Property.RENDER_ORDER);\n  }\n\n  /**\n   * Get the style for features.  This returns whatever was passed to the `style`\n   * option at construction or to the `setStyle` method.\n   * @return {import(\"../style/Style.js\").StyleLike|import(\"../style/flat.js\").FlatStyleLike|null|undefined} Layer style.\n   * @api\n   */\n  getStyle() {\n    return this.style_;\n  }\n\n  /**\n   * Get the style function.\n   * @return {import(\"../style/Style.js\").StyleFunction|undefined} Layer style function.\n   * @api\n   */\n  getStyleFunction() {\n    return this.styleFunction_;\n  }\n\n  /**\n   * @return {boolean} Whether the rendered layer should be updated while\n   *     animating.\n   */\n  getUpdateWhileAnimating() {\n    return this.updateWhileAnimating_;\n  }\n\n  /**\n   * @return {boolean} Whether the rendered layer should be updated while\n   *     interacting.\n   */\n  getUpdateWhileInteracting() {\n    return this.updateWhileInteracting_;\n  }\n\n  /**\n   * Render declutter items for this layer\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   * @param {import(\"../layer/Layer.js\").State} layerState Layer state.\n   * @override\n   */\n  renderDeclutter(frameState, layerState) {\n    const declutterGroup = this.getDeclutter();\n    if (declutterGroup in frameState.declutter === false) {\n      frameState.declutter[declutterGroup] = new RBush(9);\n    }\n    this.getRenderer().renderDeclutter(frameState, layerState);\n  }\n\n  /**\n   * @param {import(\"../render.js\").OrderFunction|null|undefined} renderOrder\n   *     Render order.\n   */\n  setRenderOrder(renderOrder) {\n    this.set(Property.RENDER_ORDER, renderOrder);\n  }\n\n  /**\n   * Set the style for features.  This can be a single style object, an array\n   * of styles, or a function that takes a feature and resolution and returns\n   * an array of styles. If set to `null`, the layer has no style (a `null` style),\n   * so only features that have their own styles will be rendered in the layer. Call\n   * `setStyle()` without arguments to reset to the default style. See\n   * [the ol/style/Style module]{@link module:ol/style/Style~Style} for information on the default style.\n   *\n   * If your layer has a static style, you can use [flat style]{@link module:ol/style/flat~FlatStyle} object\n   * literals instead of using the `Style` and symbolizer constructors (`Fill`, `Stroke`, etc.):\n   * ```js\n   * vectorLayer.setStyle({\n   *   \"fill-color\": \"yellow\",\n   *   \"stroke-color\": \"black\",\n   *   \"stroke-width\": 4\n   * })\n   * ```\n   *\n   * @param {import(\"../style/Style.js\").StyleLike|import(\"../style/flat.js\").FlatStyleLike|null} [style] Layer style.\n   * @api\n   */\n  setStyle(style) {\n    this.style_ = style === undefined ? createDefaultStyle : style;\n    const styleLike = toStyleLike(style);\n    this.styleFunction_ = style === null ? undefined : toStyleFunction(styleLike);\n    this.changed();\n  }\n\n  /**\n   * @param {boolean|string|number} declutter Declutter images and text.\n   * @api\n   */\n  setDeclutter(declutter) {\n    this.declutter_ = declutter ? String(declutter) : undefined;\n    this.changed();\n  }\n}\n\n/**\n * Coerce the allowed style types into a shorter list of types.  Flat styles, arrays of flat\n * styles, and arrays of rules are converted into style functions.\n *\n * @param {import(\"../style/Style.js\").StyleLike|import(\"../style/flat.js\").FlatStyleLike|null} [style] Layer style.\n * @return {import(\"../style/Style.js\").StyleLike|null} The style.\n */\nfunction toStyleLike(style) {\n  if (style === undefined) {\n    return createDefaultStyle;\n  }\n  if (!style) {\n    return null;\n  }\n  if (typeof style === 'function') {\n    return style;\n  }\n  if (style instanceof Style) {\n    return style;\n  }\n  if (!Array.isArray(style)) {\n    return flatStylesToStyleFunction([style]);\n  }\n  if (style.length === 0) {\n    return [];\n  }\n  const length = style.length;\n  const first = style[0];\n  if (first instanceof Style) {\n    /**\n     * @type {Array<Style>}\n     */\n    const styles = new Array(length);\n    for (let i = 0; i < length; ++i) {\n      const candidate = style[i];\n      if (!(candidate instanceof Style)) {\n        throw new Error('Expected a list of style instances');\n      }\n      styles[i] = candidate;\n    }\n    return styles;\n  }\n  if ('style' in first) {\n    /**\n     * @type Array<import(\"../style/flat.js\").Rule>\n     */\n    const rules = new Array(length);\n    for (let i = 0; i < length; ++i) {\n      const candidate = style[i];\n      if (!('style' in candidate)) {\n        throw new Error('Expected a list of rules with a style property');\n      }\n      rules[i] = candidate;\n    }\n    return rulesToStyleFunction(rules);\n  }\n  const flatStyles = /** @type {Array<import(\"../style/flat.js\").FlatStyle>} */style;\n  return flatStylesToStyleFunction(flatStyles);\n}\nexport default BaseVectorLayer;"],
  "mappings": "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",
  "names": ["context", "context"]
}
