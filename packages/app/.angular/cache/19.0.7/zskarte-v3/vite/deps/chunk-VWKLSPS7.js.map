{
  "version": 3,
  "sources": ["../../../../../../../../node_modules/ol/format/Feature.js", "../../../../../../../../node_modules/ol/format/JSONFeature.js", "../../../../../../../../node_modules/ol/format/GeoJSON.js"],
  "sourcesContent": ["/**\n * @module ol/format/Feature\n */\nimport Feature from '../Feature.js';\nimport RenderFeature from '../render/Feature.js';\nimport { GeometryCollection, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon } from '../geom.js';\nimport { abstract } from '../util.js';\nimport { equivalent as equivalentProjection, get as getProjection, getTransform, transformExtent } from '../proj.js';\nimport { linearRingsAreOriented, linearRingssAreOriented, orientLinearRings, orientLinearRingsArray } from '../geom/flat/orient.js';\n\n/**\n * @typedef {Object} ReadOptions\n * @property {import(\"../proj.js\").ProjectionLike} [dataProjection] Projection of the data we are reading.\n * If not provided, the projection will be derived from the data (where possible) or\n * the `dataProjection` of the format is assigned (where set). If the projection\n * can not be derived from the data and if no `dataProjection` is set for a format,\n * the features will not be reprojected.\n * @property {import(\"../extent.js\").Extent} [extent] Tile extent in map units of the tile being read.\n * This is only required when reading data with tile pixels as geometry units. When configured,\n * a `dataProjection` with `TILE_PIXELS` as `units` and the tile's pixel extent as `extent` needs to be\n * provided.\n * @property {import(\"../proj.js\").ProjectionLike} [featureProjection] Projection of the feature geometries\n * created by the format reader. If not provided, features will be returned in the\n * `dataProjection`.\n */\n\n/**\n * @typedef {Object} WriteOptions\n * @property {import(\"../proj.js\").ProjectionLike} [dataProjection] Projection of the data we are writing.\n * If not provided, the `dataProjection` of the format is assigned (where set).\n * If no `dataProjection` is set for a format, the features will be returned\n * in the `featureProjection`.\n * @property {import(\"../proj.js\").ProjectionLike} [featureProjection] Projection of the feature geometries\n * that will be serialized by the format writer. If not provided, geometries are assumed\n * to be in the `dataProjection` if that is set; in other words, they are not transformed.\n * @property {boolean} [rightHanded] When writing geometries, follow the right-hand\n * rule for linear ring orientation.  This means that polygons will have counter-clockwise\n * exterior rings and clockwise interior rings.  By default, coordinates are serialized\n * as they are provided at construction.  If `true`, the right-hand rule will\n * be applied.  If `false`, the left-hand rule will be applied (clockwise for\n * exterior and counter-clockwise for interior rings).  Note that not all\n * formats support this.  The GeoJSON format does use this property when writing\n * geometries.\n * @property {number} [decimals] Maximum number of decimal places for coordinates.\n * Coordinates are stored internally as floats, but floating-point arithmetic can create\n * coordinates with a large number of decimal places, not generally wanted on output.\n * Set a number here to round coordinates. Can also be used to ensure that\n * coordinates read in can be written back out with the same number of decimals.\n * Default is no rounding.\n */\n\n/**\n * @typedef {'arraybuffer' | 'json' | 'text' | 'xml'} Type\n */\n\n/**\n * @typedef {Object} SimpleGeometryObject\n * @property {import('../geom/Geometry.js').Type} type Type.\n * @property {Array<number>} flatCoordinates Flat coordinates.\n * @property {Array<number>|Array<Array<number>>} [ends] Ends or endss.\n * @property {import('../geom/Geometry.js').GeometryLayout} [layout] Layout.\n */\n\n/**\n * @typedef {Array<GeometryObject>} GeometryCollectionObject\n */\n\n/**\n * @typedef {SimpleGeometryObject|GeometryCollectionObject} GeometryObject\n */\n\n/**\n * @typedef {Object} FeatureObject\n * @property {string|number} [id] Id.\n * @property {GeometryObject} [geometry] Geometry.\n * @property {Object<string, *>} [properties] Properties.\n */\n\n/***\n * @template {import('../Feature.js').FeatureLike} T\n * @typedef {T extends RenderFeature ? typeof RenderFeature : typeof Feature} FeatureToFeatureClass\n */\n\n/***\n * @template {import(\"../Feature.js\").FeatureClass} T\n * @typedef {T[keyof T] extends RenderFeature ? RenderFeature : Feature} FeatureClassToFeature\n */\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Base class for feature formats.\n * {@link module:ol/format/Feature~FeatureFormat} subclasses provide the ability to decode and encode\n * {@link module:ol/Feature~Feature} objects from a variety of commonly used geospatial\n * file formats.  See the documentation for each format for more details.\n *\n * @template {import('../Feature.js').FeatureLike} [FeatureType=import(\"../Feature.js\").default]\n * @abstract\n * @api\n */\nclass FeatureFormat {\n  constructor() {\n    /**\n     * @protected\n     * @type {import(\"../proj/Projection.js\").default|undefined}\n     */\n    this.dataProjection = undefined;\n\n    /**\n     * @protected\n     * @type {import(\"../proj/Projection.js\").default|undefined}\n     */\n    this.defaultFeatureProjection = undefined;\n\n    /**\n     * @protected\n     * @type {FeatureToFeatureClass<FeatureType>}\n     */\n    this.featureClass = /** @type {FeatureToFeatureClass<FeatureType>} */\n    Feature;\n\n    /**\n     * A list media types supported by the format in descending order of preference.\n     * @type {Array<string>}\n     */\n    this.supportedMediaTypes = null;\n  }\n\n  /**\n   * Adds the data projection to the read options.\n   * @param {Document|Element|Object|string} source Source.\n   * @param {ReadOptions} [options] Options.\n   * @return {ReadOptions|undefined} Options.\n   * @protected\n   */\n  getReadOptions(source, options) {\n    if (options) {\n      let dataProjection = options.dataProjection ? getProjection(options.dataProjection) : this.readProjection(source);\n      if (options.extent && dataProjection && dataProjection.getUnits() === 'tile-pixels') {\n        dataProjection = getProjection(dataProjection);\n        dataProjection.setWorldExtent(options.extent);\n      }\n      options = {\n        dataProjection: dataProjection,\n        featureProjection: options.featureProjection\n      };\n    }\n    return this.adaptOptions(options);\n  }\n\n  /**\n   * Sets the `dataProjection` on the options, if no `dataProjection`\n   * is set.\n   * @param {WriteOptions|ReadOptions|undefined} options\n   *     Options.\n   * @protected\n   * @return {WriteOptions|ReadOptions|undefined}\n   *     Updated options.\n   */\n  adaptOptions(options) {\n    return Object.assign({\n      dataProjection: this.dataProjection,\n      featureProjection: this.defaultFeatureProjection,\n      featureClass: this.featureClass\n    }, options);\n  }\n\n  /**\n   * @abstract\n   * @return {Type} The format type.\n   */\n  getType() {\n    return abstract();\n  }\n\n  /**\n   * Read a single feature from a source.\n   *\n   * @abstract\n   * @param {Document|Element|Object|string} source Source.\n   * @param {ReadOptions} [options] Read options.\n   * @return {FeatureType|Array<FeatureType>} Feature.\n   */\n  readFeature(source, options) {\n    return abstract();\n  }\n\n  /**\n   * Read all features from a source.\n   *\n   * @abstract\n   * @param {Document|Element|ArrayBuffer|Object|string} source Source.\n   * @param {ReadOptions} [options] Read options.\n   * @return {Array<FeatureType>} Features.\n   */\n  readFeatures(source, options) {\n    return abstract();\n  }\n\n  /**\n   * Read a single geometry from a source.\n   *\n   * @abstract\n   * @param {Document|Element|Object|string} source Source.\n   * @param {ReadOptions} [options] Read options.\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\n   */\n  readGeometry(source, options) {\n    return abstract();\n  }\n\n  /**\n   * Read the projection from a source.\n   *\n   * @abstract\n   * @param {Document|Element|Object|string} source Source.\n   * @return {import(\"../proj/Projection.js\").default|undefined} Projection.\n   */\n  readProjection(source) {\n    return abstract();\n  }\n\n  /**\n   * Encode a feature in this format.\n   *\n   * @abstract\n   * @param {Feature} feature Feature.\n   * @param {WriteOptions} [options] Write options.\n   * @return {string|ArrayBuffer} Result.\n   */\n  writeFeature(feature, options) {\n    return abstract();\n  }\n\n  /**\n   * Encode an array of features in this format.\n   *\n   * @abstract\n   * @param {Array<Feature>} features Features.\n   * @param {WriteOptions} [options] Write options.\n   * @return {string|ArrayBuffer} Result.\n   */\n  writeFeatures(features, options) {\n    return abstract();\n  }\n\n  /**\n   * Write a single geometry in this format.\n   *\n   * @abstract\n   * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n   * @param {WriteOptions} [options] Write options.\n   * @return {string|ArrayBuffer} Result.\n   */\n  writeGeometry(geometry, options) {\n    return abstract();\n  }\n}\nexport default FeatureFormat;\n\n/**\n * @template {import(\"../geom/Geometry.js\").default|RenderFeature} T\n * @param {T} geometry Geometry.\n * @param {boolean} write Set to true for writing, false for reading.\n * @param {WriteOptions|ReadOptions} [options] Options.\n * @return {T} Transformed geometry.\n */\nexport function transformGeometryWithOptions(geometry, write, options) {\n  const featureProjection = options ? getProjection(options.featureProjection) : null;\n  const dataProjection = options ? getProjection(options.dataProjection) : null;\n  let transformed = geometry;\n  if (featureProjection && dataProjection && !equivalentProjection(featureProjection, dataProjection)) {\n    if (write) {\n      transformed = /** @type {T} */geometry.clone();\n    }\n    const fromProjection = write ? featureProjection : dataProjection;\n    const toProjection = write ? dataProjection : featureProjection;\n    if (fromProjection.getUnits() === 'tile-pixels') {\n      transformed.transform(fromProjection, toProjection);\n    } else {\n      transformed.applyTransform(getTransform(fromProjection, toProjection));\n    }\n  }\n  if (write && options && /** @type {WriteOptions} */options.decimals !== undefined) {\n    const power = Math.pow(10, /** @type {WriteOptions} */options.decimals);\n    // if decimals option on write, round each coordinate appropriately\n    /**\n     * @param {Array<number>} coordinates Coordinates.\n     * @return {Array<number>} Transformed coordinates.\n     */\n    const transform = function (coordinates) {\n      for (let i = 0, ii = coordinates.length; i < ii; ++i) {\n        coordinates[i] = Math.round(coordinates[i] * power) / power;\n      }\n      return coordinates;\n    };\n    if (transformed === geometry) {\n      transformed = /** @type {T} */geometry.clone();\n    }\n    transformed.applyTransform(transform);\n  }\n  return transformed;\n}\n\n/**\n * @param {import(\"../extent.js\").Extent} extent Extent.\n * @param {ReadOptions} [options] Read options.\n * @return {import(\"../extent.js\").Extent} Transformed extent.\n */\nexport function transformExtentWithOptions(extent, options) {\n  const featureProjection = options ? getProjection(options.featureProjection) : null;\n  const dataProjection = options ? getProjection(options.dataProjection) : null;\n  if (featureProjection && dataProjection && !equivalentProjection(featureProjection, dataProjection)) {\n    return transformExtent(extent, dataProjection, featureProjection);\n  }\n  return extent;\n}\nconst GeometryConstructor = {\n  Point: Point,\n  LineString: LineString,\n  Polygon: Polygon,\n  MultiPoint: MultiPoint,\n  MultiLineString: MultiLineString,\n  MultiPolygon: MultiPolygon\n};\nfunction orientFlatCoordinates(flatCoordinates, ends, stride) {\n  if (Array.isArray(ends[0])) {\n    // MultiPolagon\n    if (!linearRingssAreOriented(flatCoordinates, 0, ends, stride)) {\n      flatCoordinates = flatCoordinates.slice();\n      orientLinearRingsArray(flatCoordinates, 0, ends, stride);\n    }\n    return flatCoordinates;\n  }\n  if (!linearRingsAreOriented(flatCoordinates, 0, ends, stride)) {\n    flatCoordinates = flatCoordinates.slice();\n    orientLinearRings(flatCoordinates, 0, ends, stride);\n  }\n  return flatCoordinates;\n}\n\n/**\n * @param {FeatureObject} object Feature object.\n * @param {WriteOptions|ReadOptions} [options] Options.\n * @return {RenderFeature|Array<RenderFeature>} Render feature.\n */\nexport function createRenderFeature(object, options) {\n  const geometry = object.geometry;\n  if (!geometry) {\n    return [];\n  }\n  if (Array.isArray(geometry)) {\n    return geometry.map(geometry => createRenderFeature({\n      ...object,\n      geometry\n    })).flat();\n  }\n  const geometryType = geometry.type === 'MultiPolygon' ? 'Polygon' : geometry.type;\n  if (geometryType === 'GeometryCollection' || geometryType === 'Circle') {\n    throw new Error('Unsupported geometry type: ' + geometryType);\n  }\n  const stride = geometry.layout.length;\n  return transformGeometryWithOptions(new RenderFeature(geometryType, geometryType === 'Polygon' ? orientFlatCoordinates(geometry.flatCoordinates, geometry.ends, stride) : geometry.flatCoordinates, geometry.ends?.flat(), stride, object.properties || {}, object.id).enableSimplifyTransformed(), false, options);\n}\n\n/**\n * @param {GeometryObject|null} object Geometry object.\n * @param {WriteOptions|ReadOptions} [options] Options.\n * @return {import(\"../geom/Geometry.js\").default} Geometry.\n */\nexport function createGeometry(object, options) {\n  if (!object) {\n    return null;\n  }\n  if (Array.isArray(object)) {\n    const geometries = object.map(geometry => createGeometry(geometry, options));\n    return new GeometryCollection(geometries);\n  }\n  const Geometry = GeometryConstructor[object.type];\n  return transformGeometryWithOptions(new Geometry(object.flatCoordinates, object.layout, object.ends), false, options);\n}", "/**\n * @module ol/format/JSONFeature\n */\nimport FeatureFormat from './Feature.js';\nimport { abstract } from '../util.js';\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Base class for JSON feature formats.\n *\n * @template {import('../Feature.js').FeatureLike} [FeatureType=import(\"../Feature.js\").default]\n * @extends {FeatureFormat<FeatureType>}\n * @abstract\n */\nclass JSONFeature extends FeatureFormat {\n  constructor() {\n    super();\n  }\n\n  /**\n   * @return {import(\"./Feature.js\").Type} Format.\n   * @override\n   */\n  getType() {\n    return 'json';\n  }\n\n  /**\n   * Read a feature.  Only works for a single feature. Use `readFeatures` to\n   * read a feature collection.\n   *\n   * @param {ArrayBuffer|Document|Element|Object|string} source Source.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @return {FeatureType|Array<FeatureType>} Feature.\n   * @api\n   * @override\n   */\n  readFeature(source, options) {\n    return this.readFeatureFromObject(getObject(source), this.getReadOptions(source, options));\n  }\n\n  /**\n   * Read all features.  Works with both a single feature and a feature\n   * collection.\n   *\n   * @param {ArrayBuffer|Document|Element|Object|string} source Source.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @return {Array<FeatureType>} Features.\n   * @api\n   * @override\n   */\n  readFeatures(source, options) {\n    return this.readFeaturesFromObject(getObject(source), this.getReadOptions(source, options));\n  }\n\n  /**\n   * @abstract\n   * @param {Object} object Object.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @protected\n   * @return {FeatureType|Array<FeatureType>} Feature.\n   */\n  readFeatureFromObject(object, options) {\n    return abstract();\n  }\n\n  /**\n   * @abstract\n   * @param {Object} object Object.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @protected\n   * @return {Array<FeatureType>} Features.\n   */\n  readFeaturesFromObject(object, options) {\n    return abstract();\n  }\n\n  /**\n   * Read a geometry.\n   *\n   * @param {ArrayBuffer|Document|Element|Object|string} source Source.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\n   * @api\n   * @override\n   */\n  readGeometry(source, options) {\n    return this.readGeometryFromObject(getObject(source), this.getReadOptions(source, options));\n  }\n\n  /**\n   * @abstract\n   * @param {Object} object Object.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @protected\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\n   */\n  readGeometryFromObject(object, options) {\n    return abstract();\n  }\n\n  /**\n   * Read the projection.\n   *\n   * @param {ArrayBuffer|Document|Element|Object|string} source Source.\n   * @return {import(\"../proj/Projection.js\").default} Projection.\n   * @api\n   * @override\n   */\n  readProjection(source) {\n    return this.readProjectionFromObject(getObject(source));\n  }\n\n  /**\n   * @abstract\n   * @param {Object} object Object.\n   * @protected\n   * @return {import(\"../proj/Projection.js\").default} Projection.\n   */\n  readProjectionFromObject(object) {\n    return abstract();\n  }\n\n  /**\n   * Encode a feature as string.\n   *\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {string} Encoded feature.\n   * @api\n   * @override\n   */\n  writeFeature(feature, options) {\n    return JSON.stringify(this.writeFeatureObject(feature, options));\n  }\n\n  /**\n   * @abstract\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {Object} Object.\n   */\n  writeFeatureObject(feature, options) {\n    return abstract();\n  }\n\n  /**\n   * Encode an array of features as string.\n   *\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {string} Encoded features.\n   * @api\n   * @override\n   */\n  writeFeatures(features, options) {\n    return JSON.stringify(this.writeFeaturesObject(features, options));\n  }\n\n  /**\n   * @abstract\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {Object} Object.\n   */\n  writeFeaturesObject(features, options) {\n    return abstract();\n  }\n\n  /**\n   * Encode a geometry as string.\n   *\n   * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {string} Encoded geometry.\n   * @api\n   * @override\n   */\n  writeGeometry(geometry, options) {\n    return JSON.stringify(this.writeGeometryObject(geometry, options));\n  }\n\n  /**\n   * @abstract\n   * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {Object} Object.\n   */\n  writeGeometryObject(geometry, options) {\n    return abstract();\n  }\n}\n\n/**\n * @param {Document|Element|Object|string} source Source.\n * @return {Object} Object.\n */\nfunction getObject(source) {\n  if (typeof source === 'string') {\n    const object = JSON.parse(source);\n    return object ? (/** @type {Object} */object) : null;\n  }\n  if (source !== null) {\n    return source;\n  }\n  return null;\n}\nexport default JSONFeature;", "/**\n * @module ol/format/GeoJSON\n */\n\nimport Feature from '../Feature.js';\nimport JSONFeature from './JSONFeature.js';\nimport RenderFeature from '../render/Feature.js';\nimport { createGeometry, createRenderFeature, transformGeometryWithOptions } from './Feature.js';\nimport { deflateCoordinatesArray, deflateMultiCoordinatesArray } from '../geom/flat/deflate.js';\nimport { getLayoutForStride } from '../geom/SimpleGeometry.js';\nimport { get as getProjection } from '../proj.js';\nimport { isEmpty } from '../obj.js';\n\n/**\n * @typedef {import(\"geojson\").GeoJSON} GeoJSONObject\n * @typedef {import(\"geojson\").Feature} GeoJSONFeature\n * @typedef {import(\"geojson\").FeatureCollection} GeoJSONFeatureCollection\n * @typedef {import(\"geojson\").Geometry} GeoJSONGeometry\n * @typedef {import(\"geojson\").Point} GeoJSONPoint\n * @typedef {import(\"geojson\").LineString} GeoJSONLineString\n * @typedef {import(\"geojson\").Polygon} GeoJSONPolygon\n * @typedef {import(\"geojson\").MultiPoint} GeoJSONMultiPoint\n * @typedef {import(\"geojson\").MultiLineString} GeoJSONMultiLineString\n * @typedef {import(\"geojson\").MultiPolygon} GeoJSONMultiPolygon\n * @typedef {import(\"geojson\").GeometryCollection} GeoJSONGeometryCollection\n */\n\n/**\n * @template {import(\"../Feature.js\").FeatureLike} [FeatureType=import(\"../Feature.js\").default]\n * @typedef {Object} Options\n *\n * @property {import(\"../proj.js\").ProjectionLike} [dataProjection='EPSG:4326'] Default data projection.\n * @property {import(\"../proj.js\").ProjectionLike} [featureProjection] Projection for features read or\n * written by the format.  Options passed to read or write methods will take precedence.\n * @property {string} [geometryName] Geometry name to use when creating features.\n * @property {boolean} [extractGeometryName=false] Certain GeoJSON providers include\n * the geometry_name field in the feature GeoJSON. If set to `true` the GeoJSON reader\n * will look for that field to set the geometry name. If both this field is set to `true`\n * and a `geometryName` is provided, the `geometryName` will take precedence.\n * @property {import('./Feature.js').FeatureToFeatureClass<FeatureType>} [featureClass] Feature class\n * to be used when reading features. The default is {@link module:ol/Feature~Feature}. If performance is\n * the primary concern, and features are not going to be modified or round-tripped through the format,\n * consider using {@link module:ol/render/Feature~RenderFeature}\n */\n\n/**\n * @classdesc\n * Feature format for reading and writing data in the GeoJSON format.\n *\n * @template {import('../Feature.js').FeatureLike} [FeatureType=import(\"../Feature.js\").default]\n * @extends {JSONFeature<FeatureType>}\n * @api\n */\nclass GeoJSON extends JSONFeature {\n  /**\n   * @param {Options<FeatureType>} [options] Options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n    super();\n\n    /**\n     * @type {import(\"../proj/Projection.js\").default}\n     */\n    this.dataProjection = getProjection(options.dataProjection ? options.dataProjection : 'EPSG:4326');\n    if (options.featureProjection) {\n      /**\n       * @type {import(\"../proj/Projection.js\").default}\n       */\n      this.defaultFeatureProjection = getProjection(options.featureProjection);\n    }\n    if (options.featureClass) {\n      this.featureClass = options.featureClass;\n    }\n\n    /**\n     * Name of the geometry attribute for features.\n     * @type {string|undefined}\n     * @private\n     */\n    this.geometryName_ = options.geometryName;\n\n    /**\n     * Look for the `geometry_name` in the feature GeoJSON\n     * @type {boolean|undefined}\n     * @private\n     */\n    this.extractGeometryName_ = options.extractGeometryName;\n    this.supportedMediaTypes = ['application/geo+json', 'application/vnd.geo+json'];\n  }\n\n  /**\n   * @param {Object} object Object.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @protected\n   * @return {FeatureType|Array<FeatureType>} Feature.\n   * @override\n   */\n  readFeatureFromObject(object, options) {\n    /**\n     * @type {GeoJSONFeature}\n     */\n    let geoJSONFeature = null;\n    if (object['type'] === 'Feature') {\n      geoJSONFeature = /** @type {GeoJSONFeature} */object;\n    } else {\n      geoJSONFeature = {\n        'type': 'Feature',\n        'geometry': (/** @type {GeoJSONGeometry} */object),\n        'properties': null\n      };\n    }\n    const geometry = readGeometryInternal(geoJSONFeature['geometry'], options);\n    if (this.featureClass === RenderFeature) {\n      return /** @type {FeatureType|Array<FeatureType>} */createRenderFeature({\n        geometry,\n        id: geoJSONFeature['id'],\n        properties: geoJSONFeature['properties']\n      }, options);\n    }\n    const feature = new Feature();\n    if (this.geometryName_) {\n      feature.setGeometryName(this.geometryName_);\n    } else if (this.extractGeometryName_ && geoJSONFeature['geometry_name']) {\n      feature.setGeometryName(geoJSONFeature['geometry_name']);\n    }\n    feature.setGeometry(createGeometry(geometry, options));\n    if ('id' in geoJSONFeature) {\n      feature.setId(geoJSONFeature['id']);\n    }\n    if (geoJSONFeature['properties']) {\n      feature.setProperties(geoJSONFeature['properties'], true);\n    }\n    return /** @type {FeatureType|Array<FeatureType>} */feature;\n  }\n\n  /**\n   * @param {Object} object Object.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @protected\n   * @return {Array<FeatureType>} Features.\n   * @override\n   */\n  readFeaturesFromObject(object, options) {\n    const geoJSONObject = /** @type {GeoJSONObject} */object;\n    let features = null;\n    if (geoJSONObject['type'] === 'FeatureCollection') {\n      const geoJSONFeatureCollection = /** @type {GeoJSONFeatureCollection} */\n      object;\n      features = [];\n      const geoJSONFeatures = geoJSONFeatureCollection['features'];\n      for (let i = 0, ii = geoJSONFeatures.length; i < ii; ++i) {\n        const featureObject = this.readFeatureFromObject(geoJSONFeatures[i], options);\n        if (!featureObject) {\n          continue;\n        }\n        features.push(featureObject);\n      }\n    } else {\n      features = [this.readFeatureFromObject(object, options)];\n    }\n    return /** @type {Array<FeatureType>} */features.flat();\n  }\n\n  /**\n   * @param {GeoJSONGeometry} object Object.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @protected\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\n   * @override\n   */\n  readGeometryFromObject(object, options) {\n    return readGeometry(object, options);\n  }\n\n  /**\n   * @param {Object} object Object.\n   * @protected\n   * @return {import(\"../proj/Projection.js\").default} Projection.\n   * @override\n   */\n  readProjectionFromObject(object) {\n    const crs = object['crs'];\n    let projection;\n    if (crs) {\n      if (crs['type'] == 'name') {\n        projection = getProjection(crs['properties']['name']);\n      } else if (crs['type'] === 'EPSG') {\n        projection = getProjection('EPSG:' + crs['properties']['code']);\n      } else {\n        throw new Error('Unknown SRS type');\n      }\n    } else {\n      projection = this.dataProjection;\n    }\n    return /** @type {import(\"../proj/Projection.js\").default} */projection;\n  }\n\n  /**\n   * Encode a feature as a GeoJSON Feature object.\n   *\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {GeoJSONFeature} Object.\n   * @api\n   * @override\n   */\n  writeFeatureObject(feature, options) {\n    options = this.adaptOptions(options);\n\n    /** @type {GeoJSONFeature} */\n    const object = {\n      'type': 'Feature',\n      geometry: null,\n      properties: null\n    };\n    const id = feature.getId();\n    if (id !== undefined) {\n      object.id = id;\n    }\n    if (!feature.hasProperties()) {\n      return object;\n    }\n    const properties = feature.getProperties();\n    const geometry = feature.getGeometry();\n    if (geometry) {\n      object.geometry = writeGeometry(geometry, options);\n      delete properties[feature.getGeometryName()];\n    }\n    if (!isEmpty(properties)) {\n      object.properties = properties;\n    }\n    return object;\n  }\n\n  /**\n   * Encode an array of features as a GeoJSON object.\n   *\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {GeoJSONFeatureCollection} GeoJSON Object.\n   * @api\n   * @override\n   */\n  writeFeaturesObject(features, options) {\n    options = this.adaptOptions(options);\n    const objects = [];\n    for (let i = 0, ii = features.length; i < ii; ++i) {\n      objects.push(this.writeFeatureObject(features[i], options));\n    }\n    return {\n      type: 'FeatureCollection',\n      features: objects\n    };\n  }\n\n  /**\n   * Encode a geometry as a GeoJSON object.\n   *\n   * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {GeoJSONGeometry|GeoJSONGeometryCollection} Object.\n   * @api\n   * @override\n   */\n  writeGeometryObject(geometry, options) {\n    return writeGeometry(geometry, this.adaptOptions(options));\n  }\n}\n\n/**\n * @param {GeoJSONGeometry|GeoJSONGeometryCollection} object Object.\n * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n * @return {import(\"./Feature.js\").GeometryObject} Geometry.\n */\nfunction readGeometryInternal(object, options) {\n  if (!object) {\n    return null;\n  }\n\n  /** @type {import(\"./Feature.js\").GeometryObject} */\n  let geometry;\n  switch (object['type']) {\n    case 'Point':\n      {\n        geometry = readPointGeometry(/** @type {GeoJSONPoint} */object);\n        break;\n      }\n    case 'LineString':\n      {\n        geometry = readLineStringGeometry(/** @type {GeoJSONLineString} */object);\n        break;\n      }\n    case 'Polygon':\n      {\n        geometry = readPolygonGeometry(/** @type {GeoJSONPolygon} */object);\n        break;\n      }\n    case 'MultiPoint':\n      {\n        geometry = readMultiPointGeometry(/** @type {GeoJSONMultiPoint} */object);\n        break;\n      }\n    case 'MultiLineString':\n      {\n        geometry = readMultiLineStringGeometry(/** @type {GeoJSONMultiLineString} */object);\n        break;\n      }\n    case 'MultiPolygon':\n      {\n        geometry = readMultiPolygonGeometry(/** @type {GeoJSONMultiPolygon} */object);\n        break;\n      }\n    case 'GeometryCollection':\n      {\n        geometry = readGeometryCollectionGeometry(/** @type {GeoJSONGeometryCollection} */object);\n        break;\n      }\n    default:\n      {\n        throw new Error('Unsupported GeoJSON type: ' + object['type']);\n      }\n  }\n  return geometry;\n}\n\n/**\n * @param {GeoJSONGeometry|GeoJSONGeometryCollection} object Object.\n * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n * @return {import(\"../geom/Geometry.js\").default} Geometry.\n */\nfunction readGeometry(object, options) {\n  const geometryObject = readGeometryInternal(object, options);\n  return createGeometry(geometryObject, options);\n}\n\n/**\n * @param {GeoJSONGeometryCollection} object Object.\n * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n * @return {import(\"./Feature.js\").GeometryCollectionObject} Geometry collection.\n */\nfunction readGeometryCollectionGeometry(object, options) {\n  const geometries = object['geometries'].map(\n  /**\n   * @param {GeoJSONGeometry} geometry Geometry.\n   * @return {import(\"./Feature.js\").GeometryObject} geometry Geometry.\n   */\n  function (geometry) {\n    return readGeometryInternal(geometry, options);\n  });\n  return geometries;\n}\n\n/**\n * @param {GeoJSONPoint} object Input object.\n * @return {import(\"./Feature.js\").GeometryObject} Point geometry.\n */\nfunction readPointGeometry(object) {\n  const flatCoordinates = object['coordinates'];\n  return {\n    type: 'Point',\n    flatCoordinates,\n    layout: getLayoutForStride(flatCoordinates.length)\n  };\n}\n\n/**\n * @param {GeoJSONLineString} object Object.\n * @return {import(\"./Feature.js\").GeometryObject} LineString geometry.\n */\nfunction readLineStringGeometry(object) {\n  const coordinates = object['coordinates'];\n  const flatCoordinates = coordinates.flat();\n  return {\n    type: 'LineString',\n    flatCoordinates,\n    ends: [flatCoordinates.length],\n    layout: getLayoutForStride(coordinates[0]?.length || 2)\n  };\n}\n\n/**\n * @param {GeoJSONMultiLineString} object Object.\n * @return {import(\"./Feature.js\").GeometryObject} MultiLineString geometry.\n */\nfunction readMultiLineStringGeometry(object) {\n  const coordinates = object['coordinates'];\n  const stride = coordinates[0]?.[0]?.length || 2;\n  const flatCoordinates = [];\n  const ends = deflateCoordinatesArray(flatCoordinates, 0, coordinates, stride);\n  return {\n    type: 'MultiLineString',\n    flatCoordinates,\n    ends,\n    layout: getLayoutForStride(stride)\n  };\n}\n\n/**\n * @param {GeoJSONMultiPoint} object Object.\n * @return {import(\"./Feature.js\").GeometryObject} MultiPoint geometry.\n */\nfunction readMultiPointGeometry(object) {\n  const coordinates = object['coordinates'];\n  return {\n    type: 'MultiPoint',\n    flatCoordinates: coordinates.flat(),\n    layout: getLayoutForStride(coordinates[0]?.length || 2)\n  };\n}\n\n/**\n * @param {GeoJSONMultiPolygon} object Object.\n * @return {import(\"./Feature.js\").GeometryObject} MultiPolygon geometry.\n */\nfunction readMultiPolygonGeometry(object) {\n  const coordinates = object['coordinates'];\n  const flatCoordinates = [];\n  const stride = coordinates[0]?.[0]?.[0].length || 2;\n  const endss = deflateMultiCoordinatesArray(flatCoordinates, 0, coordinates, stride);\n  return {\n    type: 'MultiPolygon',\n    flatCoordinates,\n    ends: endss,\n    layout: getLayoutForStride(stride)\n  };\n}\n\n/**\n * @param {GeoJSONPolygon} object Object.\n * @return {import(\"./Feature.js\").GeometryObject} Polygon.\n */\nfunction readPolygonGeometry(object) {\n  const coordinates = object['coordinates'];\n  const flatCoordinates = [];\n  const stride = coordinates[0]?.[0]?.length;\n  const ends = deflateCoordinatesArray(flatCoordinates, 0, coordinates, stride);\n  return {\n    type: 'Polygon',\n    flatCoordinates,\n    ends,\n    layout: getLayoutForStride(stride)\n  };\n}\n\n/**\n * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n * @return {GeoJSONGeometry} GeoJSON geometry.\n */\nfunction writeGeometry(geometry, options) {\n  geometry = transformGeometryWithOptions(geometry, true, options);\n  const type = geometry.getType();\n\n  /** @type {GeoJSONGeometry} */\n  let geoJSON;\n  switch (type) {\n    case 'Point':\n      {\n        geoJSON = writePointGeometry(/** @type {import(\"../geom/Point.js\").default} */geometry, options);\n        break;\n      }\n    case 'LineString':\n      {\n        geoJSON = writeLineStringGeometry(/** @type {import(\"../geom/LineString.js\").default} */geometry, options);\n        break;\n      }\n    case 'Polygon':\n      {\n        geoJSON = writePolygonGeometry(/** @type {import(\"../geom/Polygon.js\").default} */geometry, options);\n        break;\n      }\n    case 'MultiPoint':\n      {\n        geoJSON = writeMultiPointGeometry(/** @type {import(\"../geom/MultiPoint.js\").default} */geometry, options);\n        break;\n      }\n    case 'MultiLineString':\n      {\n        geoJSON = writeMultiLineStringGeometry(/** @type {import(\"../geom/MultiLineString.js\").default} */geometry, options);\n        break;\n      }\n    case 'MultiPolygon':\n      {\n        geoJSON = writeMultiPolygonGeometry(/** @type {import(\"../geom/MultiPolygon.js\").default} */geometry, options);\n        break;\n      }\n    case 'GeometryCollection':\n      {\n        geoJSON = writeGeometryCollectionGeometry(/** @type {import(\"../geom/GeometryCollection.js\").default} */\n        geometry, options);\n        break;\n      }\n    case 'Circle':\n      {\n        geoJSON = {\n          type: 'GeometryCollection',\n          geometries: []\n        };\n        break;\n      }\n    default:\n      {\n        throw new Error('Unsupported geometry type: ' + type);\n      }\n  }\n  return geoJSON;\n}\n\n/**\n * @param {import(\"../geom/GeometryCollection.js\").default} geometry Geometry.\n * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n * @return {GeoJSONGeometryCollection} GeoJSON geometry collection.\n */\nfunction writeGeometryCollectionGeometry(geometry, options) {\n  options = Object.assign({}, options);\n  delete options.featureProjection;\n  const geometries = geometry.getGeometriesArray().map(function (geometry) {\n    return writeGeometry(geometry, options);\n  });\n  return {\n    type: 'GeometryCollection',\n    geometries: geometries\n  };\n}\n\n/**\n * @param {import(\"../geom/LineString.js\").default} geometry Geometry.\n * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n * @return {GeoJSONGeometry} GeoJSON geometry.\n */\nfunction writeLineStringGeometry(geometry, options) {\n  return {\n    type: 'LineString',\n    coordinates: geometry.getCoordinates()\n  };\n}\n\n/**\n * @param {import(\"../geom/MultiLineString.js\").default} geometry Geometry.\n * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n * @return {GeoJSONGeometry} GeoJSON geometry.\n */\nfunction writeMultiLineStringGeometry(geometry, options) {\n  return {\n    type: 'MultiLineString',\n    coordinates: geometry.getCoordinates()\n  };\n}\n\n/**\n * @param {import(\"../geom/MultiPoint.js\").default} geometry Geometry.\n * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n * @return {GeoJSONGeometry} GeoJSON geometry.\n */\nfunction writeMultiPointGeometry(geometry, options) {\n  return {\n    type: 'MultiPoint',\n    coordinates: geometry.getCoordinates()\n  };\n}\n\n/**\n * @param {import(\"../geom/MultiPolygon.js\").default} geometry Geometry.\n * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n * @return {GeoJSONGeometry} GeoJSON geometry.\n */\nfunction writeMultiPolygonGeometry(geometry, options) {\n  let right;\n  if (options) {\n    right = options.rightHanded;\n  }\n  return {\n    type: 'MultiPolygon',\n    coordinates: geometry.getCoordinates(right)\n  };\n}\n\n/**\n * @param {import(\"../geom/Point.js\").default} geometry Geometry.\n * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n * @return {GeoJSONGeometry} GeoJSON geometry.\n */\nfunction writePointGeometry(geometry, options) {\n  return {\n    type: 'Point',\n    coordinates: geometry.getCoordinates()\n  };\n}\n\n/**\n * @param {import(\"../geom/Polygon.js\").default} geometry Geometry.\n * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n * @return {GeoJSONGeometry} GeoJSON geometry.\n */\nfunction writePolygonGeometry(geometry, options) {\n  let right;\n  if (options) {\n    right = options.rightHanded;\n  }\n  return {\n    type: 'Polygon',\n    coordinates: geometry.getCoordinates(right)\n  };\n}\nexport default GeoJSON;"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqGA,IAAM,gBAAN,MAAoB;AAAA,EAClB,cAAc;AAKZ,SAAK,iBAAiB;AAMtB,SAAK,2BAA2B;AAMhC,SAAK;AAAA,IACL;AAMA,SAAK,sBAAsB;AAAA,EAC7B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,eAAe,QAAQ,SAAS;AAC9B,QAAI,SAAS;AACX,UAAI,iBAAiB,QAAQ,iBAAiB,IAAc,QAAQ,cAAc,IAAI,KAAK,eAAe,MAAM;AAChH,UAAI,QAAQ,UAAU,kBAAkB,eAAe,SAAS,MAAM,eAAe;AACnF,yBAAiB,IAAc,cAAc;AAC7C,uBAAe,eAAe,QAAQ,MAAM;AAAA,MAC9C;AACA,gBAAU;AAAA,QACR;AAAA,QACA,mBAAmB,QAAQ;AAAA,MAC7B;AAAA,IACF;AACA,WAAO,KAAK,aAAa,OAAO;AAAA,EAClC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,aAAa,SAAS;AACpB,WAAO,OAAO,OAAO;AAAA,MACnB,gBAAgB,KAAK;AAAA,MACrB,mBAAmB,KAAK;AAAA,MACxB,cAAc,KAAK;AAAA,IACrB,GAAG,OAAO;AAAA,EACZ;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,UAAU;AACR,WAAO,SAAS;AAAA,EAClB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,YAAY,QAAQ,SAAS;AAC3B,WAAO,SAAS;AAAA,EAClB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,aAAa,QAAQ,SAAS;AAC5B,WAAO,SAAS;AAAA,EAClB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,aAAa,QAAQ,SAAS;AAC5B,WAAO,SAAS;AAAA,EAClB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,eAAe,QAAQ;AACrB,WAAO,SAAS;AAAA,EAClB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,aAAa,SAAS,SAAS;AAC7B,WAAO,SAAS;AAAA,EAClB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,cAAc,UAAU,SAAS;AAC/B,WAAO,SAAS;AAAA,EAClB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,cAAc,UAAU,SAAS;AAC/B,WAAO,SAAS;AAAA,EAClB;AACF;AACA,IAAOA,mBAAQ;AASR,SAAS,6BAA6B,UAAU,OAAO,SAAS;AACrE,QAAM,oBAAoB,UAAU,IAAc,QAAQ,iBAAiB,IAAI;AAC/E,QAAM,iBAAiB,UAAU,IAAc,QAAQ,cAAc,IAAI;AACzE,MAAI,cAAc;AAClB,MAAI,qBAAqB,kBAAkB,CAAC,WAAqB,mBAAmB,cAAc,GAAG;AACnG,QAAI,OAAO;AACT;AAAA,MAA8B,SAAS,MAAM;AAAA,IAC/C;AACA,UAAM,iBAAiB,QAAQ,oBAAoB;AACnD,UAAM,eAAe,QAAQ,iBAAiB;AAC9C,QAAI,eAAe,SAAS,MAAM,eAAe;AAC/C,kBAAY,UAAU,gBAAgB,YAAY;AAAA,IACpD,OAAO;AACL,kBAAY,eAAe,aAAa,gBAAgB,YAAY,CAAC;AAAA,IACvE;AAAA,EACF;AACA,MAAI,SAAS;AAAA,EAAsC,QAAQ,aAAa,QAAW;AACjF,UAAM,QAAQ,KAAK;AAAA,MAAI;AAAA;AAAA,MAA+B,QAAQ;AAAA,IAAQ;AAMtE,UAAM,YAAY,SAAU,aAAa;AACvC,eAAS,IAAI,GAAG,KAAK,YAAY,QAAQ,IAAI,IAAI,EAAE,GAAG;AACpD,oBAAY,CAAC,IAAI,KAAK,MAAM,YAAY,CAAC,IAAI,KAAK,IAAI;AAAA,MACxD;AACA,aAAO;AAAA,IACT;AACA,QAAI,gBAAgB,UAAU;AAC5B;AAAA,MAA8B,SAAS,MAAM;AAAA,IAC/C;AACA,gBAAY,eAAe,SAAS;AAAA,EACtC;AACA,SAAO;AACT;AAOO,SAAS,2BAA2B,QAAQ,SAAS;AAC1D,QAAM,oBAAoB,UAAU,IAAc,QAAQ,iBAAiB,IAAI;AAC/E,QAAM,iBAAiB,UAAU,IAAc,QAAQ,cAAc,IAAI;AACzE,MAAI,qBAAqB,kBAAkB,CAAC,WAAqB,mBAAmB,cAAc,GAAG;AACnG,WAAO,gBAAgB,QAAQ,gBAAgB,iBAAiB;AAAA,EAClE;AACA,SAAO;AACT;AACA,IAAM,sBAAsB;AAAA,EAC1B,OAAO;AAAA,EACP,YAAY;AAAA,EACZ,SAAS;AAAA,EACT,YAAY;AAAA,EACZ,iBAAiB;AAAA,EACjB,cAAc;AAChB;AACA,SAAS,sBAAsB,iBAAiB,MAAM,QAAQ;AAC5D,MAAI,MAAM,QAAQ,KAAK,CAAC,CAAC,GAAG;AAE1B,QAAI,CAAC,wBAAwB,iBAAiB,GAAG,MAAM,MAAM,GAAG;AAC9D,wBAAkB,gBAAgB,MAAM;AACxC,6BAAuB,iBAAiB,GAAG,MAAM,MAAM;AAAA,IACzD;AACA,WAAO;AAAA,EACT;AACA,MAAI,CAAC,uBAAuB,iBAAiB,GAAG,MAAM,MAAM,GAAG;AAC7D,sBAAkB,gBAAgB,MAAM;AACxC,sBAAkB,iBAAiB,GAAG,MAAM,MAAM;AAAA,EACpD;AACA,SAAO;AACT;AAOO,SAAS,oBAAoB,QAAQ,SAAS;AACnD,QAAM,WAAW,OAAO;AACxB,MAAI,CAAC,UAAU;AACb,WAAO,CAAC;AAAA,EACV;AACA,MAAI,MAAM,QAAQ,QAAQ,GAAG;AAC3B,WAAO,SAAS,IAAI,CAAAC,cAAY,oBAAoB,iCAC/C,SAD+C;AAAA,MAElD,UAAAA;AAAA,IACF,EAAC,CAAC,EAAE,KAAK;AAAA,EACX;AACA,QAAM,eAAe,SAAS,SAAS,iBAAiB,YAAY,SAAS;AAC7E,MAAI,iBAAiB,wBAAwB,iBAAiB,UAAU;AACtE,UAAM,IAAI,MAAM,gCAAgC,YAAY;AAAA,EAC9D;AACA,QAAM,SAAS,SAAS,OAAO;AAC/B,SAAO,6BAA6B,IAAID,iBAAc,cAAc,iBAAiB,YAAY,sBAAsB,SAAS,iBAAiB,SAAS,MAAM,MAAM,IAAI,SAAS,iBAAiB,SAAS,MAAM,KAAK,GAAG,QAAQ,OAAO,cAAc,CAAC,GAAG,OAAO,EAAE,EAAE,0BAA0B,GAAG,OAAO,OAAO;AACpT;AAOO,SAAS,eAAe,QAAQ,SAAS;AAC9C,MAAI,CAAC,QAAQ;AACX,WAAO;AAAA,EACT;AACA,MAAI,MAAM,QAAQ,MAAM,GAAG;AACzB,UAAM,aAAa,OAAO,IAAI,cAAY,eAAe,UAAU,OAAO,CAAC;AAC3E,WAAO,IAAI,2BAAmB,UAAU;AAAA,EAC1C;AACA,QAAM,WAAW,oBAAoB,OAAO,IAAI;AAChD,SAAO,6BAA6B,IAAI,SAAS,OAAO,iBAAiB,OAAO,QAAQ,OAAO,IAAI,GAAG,OAAO,OAAO;AACtH;;;AC7WA,IAAM,cAAN,cAA0BE,iBAAc;AAAA,EACtC,cAAc;AACZ,UAAM;AAAA,EACR;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,UAAU;AACR,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYA,YAAY,QAAQ,SAAS;AAC3B,WAAO,KAAK,sBAAsB,UAAU,MAAM,GAAG,KAAK,eAAe,QAAQ,OAAO,CAAC;AAAA,EAC3F;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYA,aAAa,QAAQ,SAAS;AAC5B,WAAO,KAAK,uBAAuB,UAAU,MAAM,GAAG,KAAK,eAAe,QAAQ,OAAO,CAAC;AAAA,EAC5F;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,sBAAsB,QAAQ,SAAS;AACrC,WAAO,SAAS;AAAA,EAClB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,uBAAuB,QAAQ,SAAS;AACtC,WAAO,SAAS;AAAA,EAClB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,aAAa,QAAQ,SAAS;AAC5B,WAAO,KAAK,uBAAuB,UAAU,MAAM,GAAG,KAAK,eAAe,QAAQ,OAAO,CAAC;AAAA,EAC5F;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,uBAAuB,QAAQ,SAAS;AACtC,WAAO,SAAS;AAAA,EAClB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,eAAe,QAAQ;AACrB,WAAO,KAAK,yBAAyB,UAAU,MAAM,CAAC;AAAA,EACxD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,yBAAyB,QAAQ;AAC/B,WAAO,SAAS;AAAA,EAClB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,aAAa,SAAS,SAAS;AAC7B,WAAO,KAAK,UAAU,KAAK,mBAAmB,SAAS,OAAO,CAAC;AAAA,EACjE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,mBAAmB,SAAS,SAAS;AACnC,WAAO,SAAS;AAAA,EAClB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,cAAc,UAAU,SAAS;AAC/B,WAAO,KAAK,UAAU,KAAK,oBAAoB,UAAU,OAAO,CAAC;AAAA,EACnE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,oBAAoB,UAAU,SAAS;AACrC,WAAO,SAAS;AAAA,EAClB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,cAAc,UAAU,SAAS;AAC/B,WAAO,KAAK,UAAU,KAAK,oBAAoB,UAAU,OAAO,CAAC;AAAA,EACnE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,oBAAoB,UAAU,SAAS;AACrC,WAAO,SAAS;AAAA,EAClB;AACF;AAMA,SAAS,UAAU,QAAQ;AACzB,MAAI,OAAO,WAAW,UAAU;AAC9B,UAAM,SAAS,KAAK,MAAM,MAAM;AAChC,WAAO;AAAA;AAAA,MAA+B;AAAA,QAAU;AAAA,EAClD;AACA,MAAI,WAAW,MAAM;AACnB,WAAO;AAAA,EACT;AACA,SAAO;AACT;AACA,IAAO,sBAAQ;;;AC5Jf,IAAM,UAAN,cAAsB,oBAAY;AAAA;AAAA;AAAA;AAAA,EAIhC,YAAY,SAAS;AACnB,cAAU,UAAU,UAAU,CAAC;AAC/B,UAAM;AAKN,SAAK,iBAAiB,IAAc,QAAQ,iBAAiB,QAAQ,iBAAiB,WAAW;AACjG,QAAI,QAAQ,mBAAmB;AAI7B,WAAK,2BAA2B,IAAc,QAAQ,iBAAiB;AAAA,IACzE;AACA,QAAI,QAAQ,cAAc;AACxB,WAAK,eAAe,QAAQ;AAAA,IAC9B;AAOA,SAAK,gBAAgB,QAAQ;AAO7B,SAAK,uBAAuB,QAAQ;AACpC,SAAK,sBAAsB,CAAC,wBAAwB,0BAA0B;AAAA,EAChF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,sBAAsB,QAAQ,SAAS;AAIrC,QAAI,iBAAiB;AACrB,QAAI,OAAO,MAAM,MAAM,WAAW;AAChC;AAAA,MAA8C;AAAA,IAChD,OAAO;AACL,uBAAiB;AAAA,QACf,QAAQ;AAAA,QACR;AAAA;AAAA,UAA2C;AAAA;AAAA,QAC3C,cAAc;AAAA,MAChB;AAAA,IACF;AACA,UAAM,WAAW,qBAAqB,eAAe,UAAU,GAAG,OAAO;AACzE,QAAI,KAAK,iBAAiBC,kBAAe;AACvC;AAAA;AAAA,QAAoD,oBAAoB;AAAA,UACtE;AAAA,UACA,IAAI,eAAe,IAAI;AAAA,UACvB,YAAY,eAAe,YAAY;AAAA,QACzC,GAAG,OAAO;AAAA;AAAA,IACZ;AACA,UAAM,UAAU,IAAI,gBAAQ;AAC5B,QAAI,KAAK,eAAe;AACtB,cAAQ,gBAAgB,KAAK,aAAa;AAAA,IAC5C,WAAW,KAAK,wBAAwB,eAAe,eAAe,GAAG;AACvE,cAAQ,gBAAgB,eAAe,eAAe,CAAC;AAAA,IACzD;AACA,YAAQ,YAAY,eAAe,UAAU,OAAO,CAAC;AACrD,QAAI,QAAQ,gBAAgB;AAC1B,cAAQ,MAAM,eAAe,IAAI,CAAC;AAAA,IACpC;AACA,QAAI,eAAe,YAAY,GAAG;AAChC,cAAQ,cAAc,eAAe,YAAY,GAAG,IAAI;AAAA,IAC1D;AACA;AAAA;AAAA,MAAoD;AAAA;AAAA,EACtD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,uBAAuB,QAAQ,SAAS;AACtC,UAAM;AAAA;AAAA,MAA4C;AAAA;AAClD,QAAI,WAAW;AACf,QAAI,cAAc,MAAM,MAAM,qBAAqB;AACjD,YAAM;AAAA;AAAA,QACN;AAAA;AACA,iBAAW,CAAC;AACZ,YAAM,kBAAkB,yBAAyB,UAAU;AAC3D,eAAS,IAAI,GAAG,KAAK,gBAAgB,QAAQ,IAAI,IAAI,EAAE,GAAG;AACxD,cAAM,gBAAgB,KAAK,sBAAsB,gBAAgB,CAAC,GAAG,OAAO;AAC5E,YAAI,CAAC,eAAe;AAClB;AAAA,QACF;AACA,iBAAS,KAAK,aAAa;AAAA,MAC7B;AAAA,IACF,OAAO;AACL,iBAAW,CAAC,KAAK,sBAAsB,QAAQ,OAAO,CAAC;AAAA,IACzD;AACA;AAAA;AAAA,MAAwC,SAAS,KAAK;AAAA;AAAA,EACxD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,uBAAuB,QAAQ,SAAS;AACtC,WAAO,aAAa,QAAQ,OAAO;AAAA,EACrC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,yBAAyB,QAAQ;AAC/B,UAAM,MAAM,OAAO,KAAK;AACxB,QAAI;AACJ,QAAI,KAAK;AACP,UAAI,IAAI,MAAM,KAAK,QAAQ;AACzB,qBAAa,IAAc,IAAI,YAAY,EAAE,MAAM,CAAC;AAAA,MACtD,WAAW,IAAI,MAAM,MAAM,QAAQ;AACjC,qBAAa,IAAc,UAAU,IAAI,YAAY,EAAE,MAAM,CAAC;AAAA,MAChE,OAAO;AACL,cAAM,IAAI,MAAM,kBAAkB;AAAA,MACpC;AAAA,IACF,OAAO;AACL,mBAAa,KAAK;AAAA,IACpB;AACA;AAAA;AAAA,MAA6D;AAAA;AAAA,EAC/D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,mBAAmB,SAAS,SAAS;AACnC,cAAU,KAAK,aAAa,OAAO;AAGnC,UAAM,SAAS;AAAA,MACb,QAAQ;AAAA,MACR,UAAU;AAAA,MACV,YAAY;AAAA,IACd;AACA,UAAM,KAAK,QAAQ,MAAM;AACzB,QAAI,OAAO,QAAW;AACpB,aAAO,KAAK;AAAA,IACd;AACA,QAAI,CAAC,QAAQ,cAAc,GAAG;AAC5B,aAAO;AAAA,IACT;AACA,UAAM,aAAa,QAAQ,cAAc;AACzC,UAAM,WAAW,QAAQ,YAAY;AACrC,QAAI,UAAU;AACZ,aAAO,WAAW,cAAc,UAAU,OAAO;AACjD,aAAO,WAAW,QAAQ,gBAAgB,CAAC;AAAA,IAC7C;AACA,QAAI,CAAC,QAAQ,UAAU,GAAG;AACxB,aAAO,aAAa;AAAA,IACtB;AACA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,oBAAoB,UAAU,SAAS;AACrC,cAAU,KAAK,aAAa,OAAO;AACnC,UAAM,UAAU,CAAC;AACjB,aAAS,IAAI,GAAG,KAAK,SAAS,QAAQ,IAAI,IAAI,EAAE,GAAG;AACjD,cAAQ,KAAK,KAAK,mBAAmB,SAAS,CAAC,GAAG,OAAO,CAAC;AAAA,IAC5D;AACA,WAAO;AAAA,MACL,MAAM;AAAA,MACN,UAAU;AAAA,IACZ;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,oBAAoB,UAAU,SAAS;AACrC,WAAO,cAAc,UAAU,KAAK,aAAa,OAAO,CAAC;AAAA,EAC3D;AACF;AAOA,SAAS,qBAAqB,QAAQ,SAAS;AAC7C,MAAI,CAAC,QAAQ;AACX,WAAO;AAAA,EACT;AAGA,MAAI;AACJ,UAAQ,OAAO,MAAM,GAAG;AAAA,IACtB,KAAK,SACH;AACE,iBAAW;AAAA;AAAA,QAA6C;AAAA,MAAM;AAC9D;AAAA,IACF;AAAA,IACF,KAAK,cACH;AACE,iBAAW;AAAA;AAAA,QAAuD;AAAA,MAAM;AACxE;AAAA,IACF;AAAA,IACF,KAAK,WACH;AACE,iBAAW;AAAA;AAAA,QAAiD;AAAA,MAAM;AAClE;AAAA,IACF;AAAA,IACF,KAAK,cACH;AACE,iBAAW;AAAA;AAAA,QAAuD;AAAA,MAAM;AACxE;AAAA,IACF;AAAA,IACF,KAAK,mBACH;AACE,iBAAW;AAAA;AAAA,QAAiE;AAAA,MAAM;AAClF;AAAA,IACF;AAAA,IACF,KAAK,gBACH;AACE,iBAAW;AAAA;AAAA,QAA2D;AAAA,MAAM;AAC5E;AAAA,IACF;AAAA,IACF,KAAK,sBACH;AACE,iBAAW;AAAA;AAAA,QAAuE;AAAA,MAAM;AACxF;AAAA,IACF;AAAA,IACF,SACE;AACE,YAAM,IAAI,MAAM,+BAA+B,OAAO,MAAM,CAAC;AAAA,IAC/D;AAAA,EACJ;AACA,SAAO;AACT;AAOA,SAAS,aAAa,QAAQ,SAAS;AACrC,QAAM,iBAAiB,qBAAqB,QAAQ,OAAO;AAC3D,SAAO,eAAe,gBAAgB,OAAO;AAC/C;AAOA,SAAS,+BAA+B,QAAQ,SAAS;AACvD,QAAM,aAAa,OAAO,YAAY,EAAE;AAAA;AAAA;AAAA;AAAA;AAAA,IAKxC,SAAU,UAAU;AAClB,aAAO,qBAAqB,UAAU,OAAO;AAAA,IAC/C;AAAA,EAAC;AACD,SAAO;AACT;AAMA,SAAS,kBAAkB,QAAQ;AACjC,QAAM,kBAAkB,OAAO,aAAa;AAC5C,SAAO;AAAA,IACL,MAAM;AAAA,IACN;AAAA,IACA,QAAQ,mBAAmB,gBAAgB,MAAM;AAAA,EACnD;AACF;AAMA,SAAS,uBAAuB,QAAQ;AACtC,QAAM,cAAc,OAAO,aAAa;AACxC,QAAM,kBAAkB,YAAY,KAAK;AACzC,SAAO;AAAA,IACL,MAAM;AAAA,IACN;AAAA,IACA,MAAM,CAAC,gBAAgB,MAAM;AAAA,IAC7B,QAAQ,mBAAmB,YAAY,CAAC,GAAG,UAAU,CAAC;AAAA,EACxD;AACF;AAMA,SAAS,4BAA4B,QAAQ;AAC3C,QAAM,cAAc,OAAO,aAAa;AACxC,QAAM,SAAS,YAAY,CAAC,IAAI,CAAC,GAAG,UAAU;AAC9C,QAAM,kBAAkB,CAAC;AACzB,QAAM,OAAO,wBAAwB,iBAAiB,GAAG,aAAa,MAAM;AAC5E,SAAO;AAAA,IACL,MAAM;AAAA,IACN;AAAA,IACA;AAAA,IACA,QAAQ,mBAAmB,MAAM;AAAA,EACnC;AACF;AAMA,SAAS,uBAAuB,QAAQ;AACtC,QAAM,cAAc,OAAO,aAAa;AACxC,SAAO;AAAA,IACL,MAAM;AAAA,IACN,iBAAiB,YAAY,KAAK;AAAA,IAClC,QAAQ,mBAAmB,YAAY,CAAC,GAAG,UAAU,CAAC;AAAA,EACxD;AACF;AAMA,SAAS,yBAAyB,QAAQ;AACxC,QAAM,cAAc,OAAO,aAAa;AACxC,QAAM,kBAAkB,CAAC;AACzB,QAAM,SAAS,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,UAAU;AAClD,QAAM,QAAQ,6BAA6B,iBAAiB,GAAG,aAAa,MAAM;AAClF,SAAO;AAAA,IACL,MAAM;AAAA,IACN;AAAA,IACA,MAAM;AAAA,IACN,QAAQ,mBAAmB,MAAM;AAAA,EACnC;AACF;AAMA,SAAS,oBAAoB,QAAQ;AACnC,QAAM,cAAc,OAAO,aAAa;AACxC,QAAM,kBAAkB,CAAC;AACzB,QAAM,SAAS,YAAY,CAAC,IAAI,CAAC,GAAG;AACpC,QAAM,OAAO,wBAAwB,iBAAiB,GAAG,aAAa,MAAM;AAC5E,SAAO;AAAA,IACL,MAAM;AAAA,IACN;AAAA,IACA;AAAA,IACA,QAAQ,mBAAmB,MAAM;AAAA,EACnC;AACF;AAOA,SAAS,cAAc,UAAU,SAAS;AACxC,aAAW,6BAA6B,UAAU,MAAM,OAAO;AAC/D,QAAM,OAAO,SAAS,QAAQ;AAG9B,MAAI;AACJ,UAAQ,MAAM;AAAA,IACZ,KAAK,SACH;AACE,gBAAU;AAAA;AAAA,QAAoE;AAAA,QAAU;AAAA,MAAO;AAC/F;AAAA,IACF;AAAA,IACF,KAAK,cACH;AACE,gBAAU;AAAA;AAAA,QAA8E;AAAA,QAAU;AAAA,MAAO;AACzG;AAAA,IACF;AAAA,IACF,KAAK,WACH;AACE,gBAAU;AAAA;AAAA,QAAwE;AAAA,QAAU;AAAA,MAAO;AACnG;AAAA,IACF;AAAA,IACF,KAAK,cACH;AACE,gBAAU;AAAA;AAAA,QAA8E;AAAA,QAAU;AAAA,MAAO;AACzG;AAAA,IACF;AAAA,IACF,KAAK,mBACH;AACE,gBAAU;AAAA;AAAA,QAAwF;AAAA,QAAU;AAAA,MAAO;AACnH;AAAA,IACF;AAAA,IACF,KAAK,gBACH;AACE,gBAAU;AAAA;AAAA,QAAkF;AAAA,QAAU;AAAA,MAAO;AAC7G;AAAA,IACF;AAAA,IACF,KAAK,sBACH;AACE,gBAAU;AAAA;AAAA,QACV;AAAA,QAAU;AAAA,MAAO;AACjB;AAAA,IACF;AAAA,IACF,KAAK,UACH;AACE,gBAAU;AAAA,QACR,MAAM;AAAA,QACN,YAAY,CAAC;AAAA,MACf;AACA;AAAA,IACF;AAAA,IACF,SACE;AACE,YAAM,IAAI,MAAM,gCAAgC,IAAI;AAAA,IACtD;AAAA,EACJ;AACA,SAAO;AACT;AAOA,SAAS,gCAAgC,UAAU,SAAS;AAC1D,YAAU,OAAO,OAAO,CAAC,GAAG,OAAO;AACnC,SAAO,QAAQ;AACf,QAAM,aAAa,SAAS,mBAAmB,EAAE,IAAI,SAAUC,WAAU;AACvE,WAAO,cAAcA,WAAU,OAAO;AAAA,EACxC,CAAC;AACD,SAAO;AAAA,IACL,MAAM;AAAA,IACN;AAAA,EACF;AACF;AAOA,SAAS,wBAAwB,UAAU,SAAS;AAClD,SAAO;AAAA,IACL,MAAM;AAAA,IACN,aAAa,SAAS,eAAe;AAAA,EACvC;AACF;AAOA,SAAS,6BAA6B,UAAU,SAAS;AACvD,SAAO;AAAA,IACL,MAAM;AAAA,IACN,aAAa,SAAS,eAAe;AAAA,EACvC;AACF;AAOA,SAAS,wBAAwB,UAAU,SAAS;AAClD,SAAO;AAAA,IACL,MAAM;AAAA,IACN,aAAa,SAAS,eAAe;AAAA,EACvC;AACF;AAOA,SAAS,0BAA0B,UAAU,SAAS;AACpD,MAAI;AACJ,MAAI,SAAS;AACX,YAAQ,QAAQ;AAAA,EAClB;AACA,SAAO;AAAA,IACL,MAAM;AAAA,IACN,aAAa,SAAS,eAAe,KAAK;AAAA,EAC5C;AACF;AAOA,SAAS,mBAAmB,UAAU,SAAS;AAC7C,SAAO;AAAA,IACL,MAAM;AAAA,IACN,aAAa,SAAS,eAAe;AAAA,EACvC;AACF;AAOA,SAAS,qBAAqB,UAAU,SAAS;AAC/C,MAAI;AACJ,MAAI,SAAS;AACX,YAAQ,QAAQ;AAAA,EAClB;AACA,SAAO;AAAA,IACL,MAAM;AAAA,IACN,aAAa,SAAS,eAAe,KAAK;AAAA,EAC5C;AACF;AACA,IAAO,kBAAQ;",
  "names": ["Feature_default", "geometry", "Feature_default", "Feature_default", "geometry"]
}
